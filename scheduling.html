<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CleanPro - Scheduling</title>
  <link rel="stylesheet" href="css/styles.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßπ</text></svg>">
  <style>
    /* Additional calendar-specific styles */

    /* Week Selector */
    .week-selector {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-lg);
      padding: var(--space-2) var(--space-3);
    }

    .week-display {
      flex: 1;
      text-align: center;
      min-width: 200px;
    }

    .week-range {
      font-weight: 600;
      font-size: var(--text-base);
      color: var(--gray-800);
    }

    .week-selector .btn-outline {
      padding: var(--space-2) var(--space-3);
      min-width: 40px;
    }

    /* Loading spinner for buttons */
    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
      margin-right: 6px;
      vertical-align: middle;
    }

    .spinner-danger {
      border-color: rgba(220,53,69,0.3);
      border-top-color: #dc3545;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    button:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }

    /* Drag and drop styles */
    .job-chip.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .job-chip[draggable="true"] {
      cursor: grab;
    }

    .calendar-cell.drag-over {
      background: var(--primary-100);
      border: 2px dashed var(--primary-500);
    }

    .calendar-cell.drag-over-copy {
      background: var(--success-100);
      border: 2px dashed var(--success-500);
    }

    .calendar-container {
      background: white;
      border-radius: var(--radius-xl);
      border: 1px solid var(--gray-200);
      overflow: hidden;
    }
    
    .calendar-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-4) var(--space-5);
      border-bottom: 1px solid var(--gray-100);
      flex-wrap: wrap;
      gap: var(--space-3);
    }
    
    .calendar-nav {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .calendar-title {
      font-size: var(--text-xl);
      font-weight: 600;
      min-width: 200px;
      text-align: center;
    }
    
    .calendar-views {
      display: flex;
      gap: var(--space-1);
    }
    
    .view-btn {
      padding: var(--space-2) var(--space-4);
      border: 1px solid var(--gray-300);
      background: white;
      border-radius: var(--radius-md);
      font-size: var(--text-sm);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
    }
    
    .view-btn:hover {
      background: var(--gray-50);
    }
    
    .view-btn.active {
      background: var(--primary-600);
      border-color: var(--primary-600);
      color: white;
    }
    
    .calendar-grid-header {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      background: var(--gray-50);
      border-bottom: 1px solid var(--gray-200);
    }
    
    .calendar-grid-header > div {
      padding: var(--space-3);
      text-align: center;
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--gray-600);
    }
    
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
    }
    
    .calendar-cell {
      min-height: 120px;
      border-right: 1px solid var(--gray-100);
      border-bottom: 1px solid var(--gray-100);
      padding: var(--space-2);
      cursor: pointer;
      transition: background var(--transition-fast);
    }
    
    .calendar-cell:nth-child(7n) {
      border-right: none;
    }
    
    .calendar-cell:hover {
      background: var(--gray-50);
    }
    
    .calendar-cell.other-month {
      background: var(--gray-50);
    }
    
    .calendar-cell.other-month .cell-date {
      color: var(--gray-400);
    }
    
    .calendar-cell.today {
      background: var(--primary-50);
    }
    
    .calendar-cell.today .cell-date {
      background: var(--primary-600);
      color: white;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .cell-date {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: var(--space-1);
    }
    
    .cell-jobs {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .job-chip {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      transition: opacity var(--transition-fast);
    }
    
    .job-chip:hover {
      opacity: 0.8;
    }
    
    .job-chip.morning {
      background: var(--info-100);
      color: var(--info-700);
    }
    
    .job-chip.afternoon {
      background: var(--secondary-100);
      color: var(--secondary-700);
    }
    
    .job-chip.completed {
      background: var(--success-100);
      color: var(--success-700);
    }
    
    .job-chip.cancelled {
      background: var(--gray-100);
      color: var(--gray-500);
      text-decoration: line-through;
    }

    /* Status-based chip colors (replacing timeslot colors) */
    .job-chip.scheduled {
      background: var(--secondary-100);
      color: var(--secondary-700);
    }

    .job-chip.in_progress {
      background: var(--warning-100);
      color: var(--warning-700);
    }

    .job-chip.rescheduled {
      background: var(--info-100);
      color: var(--info-700);
    }
    
    .more-jobs {
      font-size: 11px;
      color: var(--gray-500);
      padding: 2px 6px;
      cursor: pointer;
    }
    
    .more-jobs:hover {
      color: var(--primary-600);
    }

    /* Status badge shown in the detailed modal */
    .status-badge {
      padding: 6px 10px;
      border-radius: 6px;
      font-weight: 700;
      text-transform: none;
    }

    .status-badge.scheduled { background: var(--secondary-100); color: var(--secondary-700); }
    .status-badge.in_progress { background: var(--warning-100); color: var(--warning-700); }
    .status-badge.completed { background: var(--success-100); color: var(--success-700); }
    .status-badge.cancelled { background: var(--gray-100); color: var(--gray-500); text-decoration: line-through; }
    .status-badge.rescheduled { background: var(--info-100); color: var(--info-700); }
    
    /* Week view */
    .week-view {
      display: none;
    }
    
    .week-view.active {
      display: block;
    }
    
    .week-grid {
      display: grid;
      grid-template-columns: 80px repeat(7, 1fr);
    }
    
    .week-header {
      display: grid;
      grid-template-columns: 80px repeat(7, 1fr);
      background: var(--gray-50);
      border-bottom: 1px solid var(--gray-200);
    }
    
    .week-header > div {
      padding: var(--space-3);
      text-align: center;
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--gray-600);
    }
    
    .week-header .today-header {
      background: var(--primary-100);
      color: var(--primary-700);
    }
    
    .time-slot-row {
      display: grid;
      grid-template-columns: 80px repeat(7, 1fr);
      border-bottom: 1px solid var(--gray-100);
    }
    
    .time-label {
      padding: var(--space-3);
      font-size: var(--text-sm);
      color: var(--gray-500);
      text-align: right;
      background: var(--gray-50);
      border-right: 1px solid var(--gray-200);
    }
    
    .time-cell {
      min-height: 80px;
      padding: var(--space-2);
      border-right: 1px solid var(--gray-100);
    }
    
    .time-cell:last-child {
      border-right: none;
    }
    
    /* Day view */
    .day-view {
      display: none;
    }
    
    .day-view.active {
      display: block;
    }
    
    .day-schedule {
      padding: var(--space-4);
    }
    
    .day-section {
      margin-bottom: var(--space-6);
    }
    
    .day-section-title {
      font-size: var(--text-lg);
      font-weight: 600;
      margin-bottom: var(--space-3);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .job-card {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-bottom: var(--space-3);
      display: flex;
      align-items: flex-start;
      gap: var(--space-4);
      transition: box-shadow var(--transition-fast);
      cursor: move;
    }

    .job-card:hover {
      box-shadow: var(--shadow-md);
    }

    .job-card.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .job-card.drag-over {
      background: var(--primary-50);
      border: 2px solid var(--primary-500);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
    }
    
    .job-card-time {
      text-align: center;
      min-width: 60px;
    }
    
    .job-card-time-slot {
      font-size: var(--text-xs);
      color: var(--gray-500);
      text-transform: uppercase;
    }
    
    .job-card-content {
      flex: 1;
    }
    
    .job-card-client {
      font-weight: 600;
      font-size: var(--text-lg);
    }
    
    .job-card-address {
      font-size: var(--text-sm);
      color: var(--gray-500);
    }
    
    .job-card-details {
      display: flex;
      gap: var(--space-4);
      margin-top: var(--space-2);
      flex-wrap: wrap;
    }
    
    .job-card-detail {
      font-size: var(--text-sm);
      color: var(--gray-600);
    }
    
    .job-card-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .month-view {
      display: none;
    }
    
    .month-view.active {
      display: block;
    }

    /* Route order badge */
    .route-order {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: var(--primary-600);
      color: white;
      border-radius: 50%;
      font-size: 10px;
      font-weight: 700;
      margin-right: 4px;
      flex-shrink: 0;
    }

    .route-order.first {
      background: var(--success-600);
    }

    .route-order.last {
      background: var(--warning-600);
    }

    /* Team jobs grouping */
    .team-jobs-group {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-lg);
      margin-bottom: var(--space-4);
      overflow: hidden;
    }

    .team-jobs-header {
      background: var(--gray-50);
      padding: var(--space-3) var(--space-4);
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .team-jobs-list {
      padding: var(--space-2);
    }

    /* Time entry warning */
    .time-entry-warning {
      background: var(--warning-50);
      border: 1px solid var(--warning-200);
      border-radius: var(--radius-md);
      padding: var(--space-3);
      margin-top: var(--space-3);
    }

    .time-entry-warning-title {
      font-weight: 600;
      color: var(--warning-700);
      margin-bottom: var(--space-2);
    }
    /* Search-select combobox styles */
    .search-select-input { cursor: text; }
    .search-select-list .search-option { padding: 8px 10px; border-bottom: 1px solid var(--gray-100); }
    .search-select-list .search-option:last-child { border-bottom: none; }
    .search-select-list .search-option:hover, .search-select-list .search-option.focused { background: var(--gray-50); }

    /* Day Jobs Modal Footer - Responsive */
    .day-jobs-footer {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      justify-content: flex-end;
    }

    .day-jobs-footer .btn {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    @media (max-width: 768px) {
      .week-view .job-chip,
      .week-grid .job-chip {
        font-size: 13px;
        padding: 6px 10px;
        margin-bottom: 4px;
        min-height: 32px;
        display: flex;
        align-items: center;
      }
      
      .week-grid .time-slot {
        min-height: 60px;
      }
    }

    /* On smaller screens, show only icons */
    @media (max-width: 640px) {
      .day-jobs-footer {
        justify-content: center;
      }
      
      .day-jobs-footer .btn {
        padding: var(--space-2) var(--space-3);
        min-width: auto;
      }
      
      .day-jobs-footer .btn .btn-text {
        display: none;
      }
      
      .day-jobs-footer .btn span:first-child {
        font-size: 1.1rem;
      }

        .calendar-actions {
        padding: var(--space-2);
        gap: var(--space-1);
      }
      
      .calendar-actions .btn {
        padding: var(--space-2) var(--space-3);
        font-size: var(--text-sm);
      }
    }

    /* Very small screens - stack buttons */
    @media (max-width: 400px) {
      .day-jobs-footer {
        flex-direction: row;
        flex-wrap: wrap;
      }
      
      .day-jobs-footer .btn {
        flex: 1 1 calc(50% - var(--space-2));
        justify-content: center;
      }

      .week-view .job-chip,
      .week-grid .job-chip {
        font-size: 14px;
        padding: 8px 12px;
        min-height: 40px;
        border-radius: var(--radius-md);
      }
    }

    /* Touch drag visual feedback */
    .job-chip.touch-dragging {
      opacity: 0.7;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
    }

    .calendar-cell.touch-drag-over,
    .week-grid .time-slot.touch-drag-over {
      background: var(--primary-100) !important;
      border: 2px dashed var(--primary-500) !important;
    }

    /* Sticky action buttons */
.calendar-actions {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--gray-50);
  padding: var(--space-3) 0;
  margin: 0 calc(-1 * var(--space-4));
  padding-left: var(--space-4);
  padding-right: var(--space-4);
  border-bottom: 1px solid var(--gray-200);
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  align-items: center;
}

/* Ensure main content area allows sticky to work */
.main-content {
  overflow-y: auto;
}

/* Add shadow when stuck */
.calendar-actions.stuck {
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

  </style>
</head>
<body>
  <div class="app-layout">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-logo">üßπ</div>
        <span class="sidebar-title">CleanPro</span>
      </div>

      <nav class="sidebar-nav">
        <div class="nav-section">
          <div class="nav-section-title">Main</div>
          <a href="dashboard.html" class="nav-item">
            <span class="nav-item-icon">üìä</span>
            <span class="nav-item-text" data-i18n="dashboard">Dashboard</span>
          </a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">Management</div>
          <a href="employees.html" class="nav-item">
            <span class="nav-item-icon">üë•</span>
            <span class="nav-item-text" data-i18n="employees">Employees</span>
          </a>
          <a href="clients.html" class="nav-item">
            <span class="nav-item-icon">üè†</span>
            <span class="nav-item-text" data-i18n="clients">Clients</span>
          </a>
          <a href="scheduling.html" class="nav-item active">
            <span class="nav-item-icon">üìÖ</span>
            <span class="nav-item-text" data-i18n="scheduling">Scheduling</span>
          </a>
          <a href="timeclock.html" class="nav-item">
            <span class="nav-item-icon">‚è±Ô∏è</span>
            <span class="nav-item-text" data-i18n="timeClock">Time Clock</span>
          </a>
          <a href="employee-hours.html" class="nav-item">
            <span class="nav-item-icon">‚è∞</span>
            <span class="nav-item-text" data-i18n="employeeHours">Employee Hours</span>
          </a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title" data-i18n="finances">Finance</div>
          <a href="finances.html" class="nav-item">
            <span class="nav-item-icon">üí∞</span>
            <span class="nav-item-text" data-i18n="finances">Finances</span>
          </a>
          <a href="reports.html" class="nav-item">
            <span class="nav-item-icon">üìà</span>
            <span class="nav-item-text" data-i18n="reports">Reports</span>
          </a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">System</div>
          <a href="audit-log.html" class="nav-item">
            <span class="nav-item-icon">üìã</span>
            <span class="nav-item-text" data-i18n="auditLog">Audit Log</span>
          </a>
        </div>
      </nav>

      <div class="sidebar-footer">
        <div class="sidebar-user">
          <div class="sidebar-user-avatar" id="userAvatar">AD</div>
          <div class="sidebar-user-info">
            <div class="sidebar-user-name" id="userName">Admin</div>
            <div class="sidebar-user-role" id="userRole">Administrator</div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Header -->
      <header class="header">
        <button class="header-menu-btn" id="menuToggle">‚ò∞</button>
        
        <div class="header-search">
          <span class="header-search-icon">üîç</span>
          <input type="text" class="header-search-input" placeholder="Search schedules..." id="searchInput">
        </div>

        <div class="header-actions">
          <button class="header-btn lang-toggle" id="langToggle">
            üåê <span id="langLabel">ES</span>
          </button>
          <button class="header-btn" id="logoutBtn" title="Logout">üö™</button>
        </div>
      </header>

      <!-- Page Content -->
      <div class="page-content">
        <div class="page-header">
          <div>
            <h1 class="page-title" data-i18n="scheduling">Scheduling</h1>
            <p class="text-gray-500"><span id="scheduleCount">0</span> jobs this month</p>
          </div>
          <div class="page-actions">
            <div class="calendar-actions" id="calendarActions">
              <button class="btn btn-secondary" id="editOfficeBtn" title="Route Start/End Locations">
                üìç Route Start/End
              </button>
              <button class="btn btn-secondary" id="autoScheduleBtn">
                <span>üîÑ</span>
                <span data-i18n="generateSchedules">Generate Schedules</span>
              </button>
              <button class="btn btn-secondary" id="distributeWeeklyBtn" title="Auto-distribute clients for the week by proximity">
                <span>üó∫Ô∏è</span>
                <span>Distribute Weekly</span>
              </button>
              <button class="btn btn-primary" id="addScheduleBtn">
                <span>‚ûï</span>
                <span data-i18n="scheduleJob">Schedule Job</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Calendar Container -->
        <div class="calendar-container">
          <!-- Calendar Toolbar -->
          <div class="calendar-toolbar">
            <div class="calendar-nav">
              <button class="btn btn-ghost btn-icon" id="prevBtn">‚óÄ</button>
              <button class="btn btn-secondary btn-sm" id="todayBtn" data-i18n="today">Today</button>
              <button class="btn btn-ghost btn-icon" id="nextBtn">‚ñ∂</button>
              <span class="calendar-title" id="calendarTitle">December 2024</span>
            </div>
            
            <div class="calendar-views">
              <button class="view-btn" data-view="day" data-i18n="viewDay">Day</button>
              <button class="view-btn" data-view="week" data-i18n="viewWeek">Week</button>
              <button class="view-btn active" data-view="month" data-i18n="viewMonth">Month</button>
            </div>

            <div class="flex gap-2">
              <select class="form-select" id="teamFilter" style="width: auto;">
                <option value="">All Teams</option>
              </select>
            </div>
          </div>

          <!-- Month View -->
          <div class="month-view active" id="monthView">
            <div class="calendar-grid-header" id="calendarHeader">
              <!-- Day headers populated by JS -->
            </div>
            <div class="calendar-grid" id="calendarGrid">
              <!-- Calendar cells populated by JS -->
            </div>
          </div>

          <!-- Week View -->
          <div class="week-view" id="weekView">
            <div class="week-header" id="weekHeader">
              <!-- Week headers populated by JS -->
            </div>
            <div id="weekContent">
              <!-- Time slots populated by JS -->
            </div>
          </div>

          <!-- Day View -->
          <div class="day-view" id="dayView">
            <div class="day-schedule" id="daySchedule">
              <!-- Day jobs populated by JS -->
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Mobile Sidebar Overlay -->
  <div class="modal-backdrop" id="sidebarOverlay"></div>

  <!-- Modal Backdrop -->
  <div class="modal-backdrop" id="modalBackdrop"></div>

  <!-- Schedule Job Modal -->
  <div class="modal modal-lg" id="scheduleModal">
    <div class="modal-header">
      <h3 class="modal-title" id="scheduleModalTitle" data-i18n="scheduleJob">Schedule Job</h3>
      <button class="modal-close" id="closeScheduleModal">‚úï</button>
    </div>
    <div class="modal-body">
      <form id="scheduleForm">
        <input type="hidden" id="scheduleId">
        
        <div class="grid grid-cols-2">
          <div class="form-group">
            <label class="form-label form-label-required" data-i18n="selectClient">Select Client</label>
            <div class="search-select" id="scheduleClientCombo" style="position:relative;">
              <div class="search-select-input" id="scheduleClientCombobox" style="display:flex; gap:6px; align-items:center;">
                <input type="text" class="form-input" id="scheduleClientSearch" placeholder="Search clients..." autocomplete="off" aria-haspopup="listbox" aria-expanded="false" />
                <span id="scheduleClientCaret" style="font-size:0.9rem; cursor:pointer;">‚ñæ</span>
              </div>
              <div class="search-select-list hidden" id="scheduleClientList" role="listbox" tabindex="-1" style="position:absolute; z-index:40; width:100%; background:white; border:1px solid var(--gray-200); box-shadow:var(--shadow-md); max-height:220px; overflow:auto; border-radius:6px;">
                <!-- options rendered here -->
              </div>
              <select class="form-select" id="scheduleClient" style="display:none;" required>
                <option value="">-- Select Client --</option>
              </select>
            </div>
          </div>
          <div class="form-group">
            <label class="form-label" data-i18n="selectTeam">Select Team <span class="text-gray-500" style="font-weight: normal; font-size: 0.9rem;">(optional)</span></label>
            <select class="form-select" id="scheduleTeam">
              <option value="">-- Select Team --</option>
            </select>
          </div>
        </div>

        <div class="grid grid-cols-2">
          <div class="form-group">
            <label class="form-label form-label-required" data-i18n="selectDate">Date</label>
            <input type="date" class="form-input" id="scheduleDate" required>
          </div>
          <!-- Time slot removed (no longer needed); keep a hidden field for backward compatibility -->
          <input type="hidden" id="scheduleTimeSlot" value="" />
        </div>

<!-- Client Info Preview -->
        <div class="card mb-4 hidden" id="clientPreview">
          <div class="card-body">
            <div class="flex justify-between items-start">
              <div>
                <div class="font-semibold" id="previewClientName">Client Name</div>
                <div class="text-sm text-gray-500" id="previewClientAddress">Address</div>
                <div class="text-sm text-gray-500" id="previewClientHouseCode" style="display: none;">üîë <span></span></div>
              </div>
              <div class="text-right">
                <div class="font-semibold text-primary" id="previewClientPrice">$0</div>
                <div class="text-sm text-gray-500" id="previewClientSchedule">Weekly</div>
              </div>
            </div>
          </div>
        </div>

<div class="form-group" id="addonsSection" style="display: none;">
          <label class="form-label" data-i18n="addOns">Extra Services (Additional Charge)</label>
          <div id="addonsContainer" class="flex flex-col gap-2">
            <!-- Populated dynamically based on client's areas -->
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" data-i18n="estimatedDuration">Estimated Duration</label>
          <select class="form-select" id="scheduleDuration">
            <option value="1">1 hour</option>
            <option value="1.5">1.5 hours</option>
            <option value="2" selected>2 hours</option>
            <option value="2.5">2.5 hours</option>
            <option value="3">3 hours</option>
            <option value="3.5">3.5 hours</option>
            <option value="4">4 hours</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label" data-i18n="status">Status</label>
          <select class="form-select" id="scheduleStatus">
            <option value="scheduled">Scheduled</option>
            <option value="in_progress">In Progress</option>
            <option value="completed">Completed</option>
            <option value="cancelled">Cancelled</option>
            <option value="rescheduled">Rescheduled</option>
          </select>
        </div>

        

        <div class="form-group">
          <label class="form-label" data-i18n="notes">Notes</label>
          <textarea class="form-input" id="scheduleNotes" rows="2" placeholder="Special instructions..."></textarea>
        </div>

        <!-- Total Price -->
        <div class="card" style="background: var(--primary-50); border-color: var(--primary-200);">
          <div class="card-body">
            <div class="flex justify-between items-center">
              <span class="font-semibold" data-i18n="total">Total Price</span>
              <span class="text-2xl font-bold text-primary" id="scheduleTotalPrice">$0.00</span>
            </div>
          </div>
        </div>
      </form>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-secondary" id="cancelScheduleBtn" data-i18n="cancel">Cancel</button>
      <button type="button" class="btn btn-primary" id="saveScheduleBtn" data-i18n="save">Save</button>
    </div>
  </div>

  <!-- View Schedule Modal -->
  <div class="modal modal-lg" id="viewScheduleModal">
    <div class="modal-header">
      <h3 class="modal-title" data-i18n="details">Job Details</h3>
      <button class="modal-close" id="closeViewScheduleModal">‚úï</button>
    </div>
    <div class="modal-body" id="viewScheduleContent">
      <!-- Populated by JS -->
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-danger" id="deleteScheduleBtn" data-i18n="delete">Delete</button>
      <button type="button" class="btn btn-secondary" id="closeViewScheduleBtn" data-i18n="close">Close</button>
      <button type="button" class="btn btn-primary" id="editScheduleBtn" data-i18n="edit">Edit</button>
    </div>
  </div>

<!-- Auto Schedule Modal -->
<div class="modal modal-lg" id="autoScheduleModal">
  <div class="modal-header">
    <h3 class="modal-title" data-i18n="generateSchedules">Generate Schedules</h3>
    <button class="modal-close" id="closeAutoScheduleModal">‚úï</button>
  </div>
  <div class="modal-body">
    <p class="mb-4">Automatically generate schedules for clients based on their schedule preferences. Only clients with existing schedule history will be included.</p>
    
    <div class="form-group">
      <label class="form-label">Select Week</label>
      <div class="week-selector">
        <button type="button" class="btn btn-outline btn-sm" id="prevWeekBtn">‚óÄ</button>
        <div class="week-display" id="weekDisplay">
          <span class="week-range" id="weekRangeText">Dec 16 - Dec 22, 2024</span>
        </div>
        <button type="button" class="btn btn-outline btn-sm" id="nextWeekBtn">‚ñ∂</button>
      </div>
      <input type="hidden" id="autoStartDate">
      <input type="hidden" id="autoEndDate">
    </div>

    <div class="form-group">
      <label class="form-label">Include Clients</label>
      <select class="form-select" id="autoClientFilter">
        <option value="all">All Active Clients (with history)</option>
        <option value="unscheduled">Only Clients Without Upcoming Schedules</option>
      </select>
    </div>

    <div class="form-group">
      <label class="form-label">Default Team Assignment</label>
      <select class="form-select" id="autoDefaultTeam">
        <option value="">Auto-assign (distribute by proximity)</option>
      </select>
    </div>

    <div class="card mt-4">
      <div class="card-body">
        <div class="flex justify-between items-center">
          <span>Estimated jobs to create:</span>
          <span class="text-2xl font-bold text-primary" id="estimatedJobs">0</span>
        </div>
      </div>
    </div>
  </div>
  <div class="modal-footer">
    <button type="button" class="btn btn-secondary" id="cancelAutoScheduleBtn" data-i18n="cancel">Cancel</button>
    <button type="button" class="btn btn-primary" id="generateSchedulesBtn">Generate Schedules</button>
  </div>
</div>

  <!-- Day Jobs Modal (for clicking on a day) -->
  <div class="modal modal-lg" id="dayJobsModal">
    <div class="modal-header">
      <h3 class="modal-title" id="dayJobsTitle">Jobs for December 15, 2024</h3>
      <button class="modal-close" id="closeDayJobsModal">‚úï</button>
    </div>
    <div class="modal-body" id="dayJobsContent">
      <!-- Populated by JS -->
    </div>
    <div class="modal-footer day-jobs-footer">
        <button type="button" class="btn btn-danger btn-sm" id="deleteAllDayJobsBtn" title="Delete All">
          <span>üóëÔ∏è</span> <span class="btn-text">Delete All</span>
        </button>
        <button type="button" class="btn btn-secondary btn-sm" id="closeDayJobsBtn" data-i18n="close">Close</button>
        <button type="button" class="btn btn-secondary btn-sm" id="previewAllRoutesBtn" title="Preview Routes">
          <span>üó∫Ô∏è</span> <span class="btn-text">Routes</span>
        </button>
        <button type="button" class="btn btn-secondary btn-sm" id="distributeAndRouteBtn" title="Distribute & Route">
          <span>üìç</span> <span class="btn-text">Distribute</span>
        </button>
        <button type="button" class="btn btn-secondary btn-sm" id="bulkAddJobsBtn" title="Add Multiple Jobs">
          <span>‚ûï‚ûï</span> <span class="btn-text">Bulk Add</span>
        </button>
        <button type="button" class="btn btn-primary btn-sm" id="addJobForDayBtn" title="Add Job">
          <span>‚ûï</span> <span class="btn-text">Add Job</span>
        </button>
    </div>
  </div>

  <!-- Bulk Add Clients Modal -->
  <div class="modal modal-lg" id="bulkAddModal">
    <div class="modal-header">
      <h3 class="modal-title">Add Multiple Clients</h3>
      <button class="modal-close" id="closeBulkAddModal">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label">Select Clients to Add</label>
        <input type="text" class="form-input" id="bulkClientSearch" placeholder="Search clients by name or address...">
      </div>
      <div class="form-group" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--gray-200); border-radius: var(--radius-md); padding: var(--space-3);">
        <div id="bulkClientCheckboxes">
          <!-- Checkboxes populated by JS -->
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Assign to Team</label>
        <select class="form-select" id="bulkTeamSelect">
          <!-- Options populated by JS, defaulting to first team -->
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Estimated Duration</label>
        <select class="form-select" id="bulkDuration">
          <option value="1">1 hour</option>
          <option value="1.5">1.5 hours</option>
          <option value="2" selected>2 hours</option>
          <option value="2.5">2.5 hours</option>
          <option value="3">3 hours</option>
          <option value="3.5">3.5 hours</option>
          <option value="4">4 hours</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-secondary" id="cancelBulkAddBtn">Cancel</button>
      <button type="button" class="btn btn-primary" id="confirmBulkAddBtn">Add Selected Clients</button>
    </div>
  </div>

  <!-- Office Address Modal -->
  <div class="modal" id="officeModal">
    <div class="modal-header">
      <h3 class="modal-title">Route Start/End Locations</h3>
      <button class="modal-close" id="closeOfficeModal">‚úï</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label class="form-label form-label-required">Start Location (Office Address)</label>
        <input type="text" class="form-input" id="officeStreet" placeholder="123 Main Street">
      </div>
      <div class="grid grid-cols-3">
        <div class="form-group">
          <label class="form-label">City</label>
          <input type="text" class="form-input" id="officeCity" placeholder="City">
        </div>
        <div class="form-group">
          <label class="form-label">State</label>
          <input type="text" class="form-input" id="officeState" placeholder="State">
        </div>
        <div class="form-group">
          <label class="form-label">ZIP</label>
          <input type="text" class="form-input" id="officeZip" placeholder="12345">
        </div>
      </div>

      <div class="form-group mt-4">
        <label class="form-check">
          <input type="checkbox" class="form-check-input" id="differentEndLocation">
          <span class="form-check-label">Use different end location</span>
        </label>
      </div>

      <div id="endLocationFields" class="hidden">
        <div class="form-group">
          <label class="form-label">End Location Address</label>
          <input type="text" class="form-input" id="endStreet" placeholder="456 End Street">
        </div>
        <div class="grid grid-cols-3">
          <div class="form-group">
            <label class="form-label">City</label>
            <input type="text" class="form-input" id="endCity" placeholder="City">
          </div>
          <div class="form-group">
            <label class="form-label">State</label>
            <input type="text" class="form-input" id="endState" placeholder="State">
          </div>
          <div class="form-group">
            <label class="form-label">ZIP</label>
            <input type="text" class="form-input" id="endZip" placeholder="12345">
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn btn-secondary" id="cancelOfficeBtn">Cancel</button>
      <button type="button" class="btn btn-primary" id="saveOfficeBtn">Save</button>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <script type="module">
    import { 
      auth, db, onAuthStateChanged, signOut,
      collection, doc, getDoc, getDocs, addDoc, updateDoc, setDoc, deleteDoc, 
      query, where, orderBy, Timestamp
    } from './js/firebase-config.js';
    import { i18n } from './js/i18n.js';
    import { 
      showToast, openModal, closeModal, closeAllModals,
      formatCurrency, formatDate, getInitials, confirmDialog,
      getNextScheduleDate, addDays
    } from './js/utils.js';
    import { logScheduleAction, logAudit, AuditActions, AuditModules, trackChanges } from './js/audit.js';

    // ============================================
    // STATE
    // ============================================
    let currentUser = null;
    let currentAdmin = null;
    let clients = [];
    let teams = [];
    let schedules = [];
    let historicalSchedules = []; // For analyzing patterns
    let timeEntries = []; // For checking active time entries
    let officeSettings = { start: null, end: null };
    let googleMapsApiKey = null;
    
    let currentView = 'month';
    let currentDate = new Date();
    let selectedDate = null;
    let editingScheduleId = null;
    let selectedClient = null;
    let teamFilter = '';
    let activeTimeEntry = null; // Track if editing a schedule with active time entry

    // ============================================
    // UTILITY FUNCTIONS FOR EXTRAS
    // ============================================
    /**
     * Calculate which extras should be included for a schedule based on the client's extras and schedule date.
     * Extras appear based on their frequency relative to previous completed schedules.
     */
    function calculateExtrasForDate(client, scheduleDate) {
      const addOns = [];
      if (!client?.areas) return addOns;

      // Get all areas across all floors
      const allFloors = ['basement', 'mainLevel', 'upstairs'];

      allFloors.forEach(floorKey => {
        const floor = client.areas[floorKey] || {};

        // Check each area in this floor
        for (const [areaId, areaConfig] of Object.entries(floor)) {
          // Skip system fields
          if (areaId === 'selected' || typeof areaConfig !== 'object') continue;

          // Only include if it's an extra (not included in base)
          if (areaConfig.selected && !areaConfig.includedInBase && areaConfig.extraPrice > 0) {
            const frequency = areaConfig.extraFrequency || 'biweekly';

            // Check if this extra should appear on this date
            if (shouldExtraAppear(client, floorKey, areaId, frequency, scheduleDate)) {
              addOns.push({
                area: `${floorKey}-${areaId}`,
                label: areaId,
                frequency: frequency,
                price: areaConfig.extraPrice
              });
            }
          }
        }
      });

      return addOns;
    }

    /**
     * Determine if an extra service should appear on a given date based on its frequency.
     * Looks at historical completed schedules to calculate the pattern.
     */
    function shouldExtraAppear(client, floorKey, areaId, frequency, scheduleDate) {
      // For now, use a simple approach:
      // Count how many visits have been completed for this client
      // Then determine if this visit number matches the frequency pattern

      const completedSchedules = historicalSchedules.filter(s =>
        s.clientId === client.id &&
        s.status === 'completed'
      ).sort((a, b) => new Date(a.date) - new Date(b.date));

      // Map frequency to visit interval
      const frequencyMap = {
        'weekly': 1,
        'biweekly': 2,
        'every3weeks': 3,
        'monthly': 4 // Approximate: 4 biweekly visits per month
      };

      const interval = frequencyMap[frequency] || 2;
      const visitNumber = completedSchedules.length + 1; // +1 for current visit

      // Simple logic: show extra every N visits based on frequency
      // Example: biweekly extra shows on visits 2, 4, 6, etc.
      return visitNumber % interval === 0;
    }

    // ============================================
    // AUTHENTICATION CHECK
    // ============================================
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUser = user;
        try {
          const adminDoc = await getDoc(doc(db, 'admins', user.uid));
          if (adminDoc.exists()) {
            currentAdmin = { id: adminDoc.id, ...adminDoc.data() };
            initializePage();
          } else {
            window.location.href = 'index.html';
          }
        } catch (error) {
          
          window.location.href = 'index.html';
        }
      } else {
        window.location.href = 'index.html';
      }
    });

    // ============================================
    // INITIALIZE PAGE
    // ============================================
    async function initializePage() {
      document.getElementById('userName').textContent = currentAdmin.name;
      document.getElementById('userAvatar').textContent = getInitials(
        currentAdmin.name.split(' ')[0], 
        currentAdmin.name.split(' ')[1] || ''
      );

      updateLanguage();
      i18n.updatePageTranslations();

      await loadGoogleMapsApiKey();
      await loadOfficeSettings();
      await loadClients();
      await loadTeams();
      await loadSchedules();
      await loadHistoricalSchedules();

      renderCalendar();
      updateOfficeDisplay();
      setupEventListeners();
      initStickyActions();

      // Check URL params
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('action') === 'add') {
        openAddScheduleModal();
      }
    }

    // ============================================
    // LOAD DATA
    // ============================================
    async function loadGoogleMapsApiKey() {
      try {
        const configDoc = await getDoc(doc(db, 'config', 'googleMaps'));
        if (configDoc.exists()) {
          googleMapsApiKey = configDoc.data().apiKey;
        }
      } catch (e) {
        
      }
    }

    async function loadOfficeSettings() {
      try {
        const configDoc = await getDoc(doc(db, 'config', 'officeSettings'));
        if (configDoc.exists()) {
          officeSettings = configDoc.data();
        }
      } catch (e) {
        
      }
    }

    async function loadClients() {
      try {
        const q = query(collection(db, 'clients'), where('isActive', '==', true), orderBy('lastName'));
        const snapshot = await getDocs(q);
        clients = [];
        snapshot.forEach(doc => clients.push({ id: doc.id, ...doc.data() }));
        populateClientSelect();
      } catch (error) {
        
      }
    }

    async function loadTeams() {
      try {
        const q = query(collection(db, 'teams'), where('isActive', '==', true), orderBy('name'));
        const snapshot = await getDocs(q);
        teams = [];
        snapshot.forEach(doc => teams.push({ id: doc.id, ...doc.data() }));
        populateTeamSelect();
      } catch (error) {
        
      }
    }

    async function loadSchedules() {
      try {
        // Calculate visible date range based on current view
        let startDate, endDate;
        
        if (currentView === 'month') {
          // Load current month + buffer for prev/next month days shown
          startDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
          endDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0);
        } else if (currentView === 'week') {
          // Load current week + 1 week buffer each side
          const weekStart = getStartOfWeek(currentDate);
          startDate = addDays(weekStart, -7);
          endDate = addDays(weekStart, 13);
        } else {
          // Day view - load current day + 1 day buffer
          startDate = addDays(currentDate, -1);
          endDate = addDays(currentDate, 1);
        }
        
        const startStr = formatDateStr(startDate);
        const endStr = formatDateStr(endDate);
        
        const q = query(
          collection(db, 'schedules'),
          where('date', '>=', startStr),
          where('date', '<=', endStr)
        );
        const snapshot = await getDocs(q);
        
        schedules = [];
        snapshot.forEach(doc => schedules.push({ id: doc.id, ...doc.data() }));
        
      } catch (error) {
        
      }
    }

    async function loadHistoricalSchedules() {
      try {
        // Load past 2 months of completed schedules for pattern analysis
        const twoMonthsAgo = addDays(new Date(), -60);
        const startStr = formatDateStr(twoMonthsAgo);

        const q = query(
          collection(db, 'schedules'),
          where('date', '>=', startStr),
          where('status', '==', 'completed')
        );
        const snapshot = await getDocs(q);
        
        historicalSchedules = [];
        snapshot.forEach(doc => historicalSchedules.push({ id: doc.id, ...doc.data() }));
      } catch (error) {
        
      }
    }

    async function loadTimeEntriesForSchedule(scheduleId) {
      try {
        const q = query(
          collection(db, 'timeEntries'),
          where('scheduleId', '==', scheduleId)
        );
        const snapshot = await getDocs(q);
        const entries = [];
        snapshot.forEach(doc => entries.push({ id: doc.id, ...doc.data() }));
        return entries.filter(e => !e.clockOut); // Return only open entries
      } catch (error) {
        
        return [];
      }
    }

    // ============================================
    // CALENDAR RENDERING
    // ============================================
    function renderCalendar() {
      updateCalendarTitle();
      updateScheduleCount();
      
      if (currentView === 'month') {
        renderMonthView();
      } else if (currentView === 'week') {
        renderWeekView();
      } else if (currentView === 'day') {
        renderDayView();
      }
    }
    
    function updateScheduleCount() {
      let filteredSchedules = schedules;
      if (teamFilter) {
        filteredSchedules = filteredSchedules.filter(s => s.teamId === teamFilter);
      }
      
      let count = 0;
      let label = '';
      
      if (currentView === 'month') {
        count = filteredSchedules.filter(s => {
          const d = new Date(s.date);
          return d.getMonth() === currentDate.getMonth() && d.getFullYear() === currentDate.getFullYear();
        }).length;
        label = 'jobs this month';
      } else if (currentView === 'week') {
        const startOfWeek = getStartOfWeek(currentDate);
        const endOfWeek = addDays(startOfWeek, 6);
        const startStr = formatDateStr(startOfWeek);
        const endStr = formatDateStr(endOfWeek);
        count = filteredSchedules.filter(s => s.date >= startStr && s.date <= endStr).length;
        label = 'jobs this week';
      } else if (currentView === 'day') {
        const dateStr = formatDateStr(currentDate);
        count = filteredSchedules.filter(s => s.date === dateStr).length;
        label = 'jobs today';
      }
      
      document.getElementById('scheduleCount').textContent = count;
      // Update the label text next to the count
      const countParent = document.getElementById('scheduleCount').parentElement;
      if (countParent) {
        countParent.innerHTML = `<span id="scheduleCount">${count}</span> ${label}`;
      }
    }

    function updateCalendarTitle() {
      const title = document.getElementById('calendarTitle');
      
      if (currentView === 'month') {
        title.textContent = i18n.getMonthName(currentDate.getMonth()) + ' ' + currentDate.getFullYear();
      } else if (currentView === 'week') {
        const startOfWeek = getStartOfWeek(currentDate);
        const endOfWeek = addDays(startOfWeek, 6);
        title.textContent = `${formatDate(startOfWeek, { month: 'short', day: 'numeric' })} - ${formatDate(endOfWeek, { month: 'short', day: 'numeric', year: 'numeric' })}`;
      } else if (currentView === 'day') {
        title.textContent = formatDate(currentDate, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
      }
    }

    function renderMonthView() {
      const header = document.getElementById('calendarHeader');
      const grid = document.getElementById('calendarGrid');
      
      // Render header
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      header.innerHTML = days.map((d, i) => `<div>${i18n.getDayName(i, true)}</div>`).join('');
      
      // Get first day of month
      const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      const startDay = firstDay.getDay();
      
      // Calculate start date (include previous month days)
      const startDate = addDays(firstDay, -startDay);
      
      // Render 6 weeks
      let html = '';
      const today = new Date();
      const todayStr = formatDateStr(today);
      
      for (let week = 0; week < 6; week++) {
        for (let day = 0; day < 7; day++) {
          const date = addDays(startDate, week * 7 + day);
          const dateStr = formatDateStr(date);
          const isOtherMonth = date.getMonth() !== currentDate.getMonth();
          const isToday = dateStr === todayStr;
          
          // Get jobs for this day
          let daySchedules = schedules.filter(s => s.date === dateStr);
          if (teamFilter) {
            daySchedules = daySchedules.filter(s => s.teamId === teamFilter);
          }
          
          html += `
            <div class="calendar-cell ${isOtherMonth ? 'other-month' : ''} ${isToday ? 'today' : ''}"
                 data-date="${dateStr}" onclick="showDayJobs('${dateStr}')">
              <div class="cell-date">${date.getDate()}</div>
              <div class="cell-jobs">
                ${renderJobChips(daySchedules, 3)}
              </div>
            </div>
          `;
        }
      }
      
      grid.innerHTML = html;
      // At the end of renderMonthView function, add:
      setTimeout(() => initDragAndDrop(), 0);
    }

    function renderJobChips(daySchedules, maxShow = 3) {
      if (daySchedules.length === 0) return '';
      
      const sorted = [...daySchedules].sort((a, b) => (Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity)) || (a.clientId || '').localeCompare(b.clientId || ''));
      
      let html = '';
      const toShow = sorted.slice(0, maxShow);
      
      toShow.forEach(schedule => {
        const client = clients.find(c => c.id === schedule.clientId);
        const clientName = client ? `${client.firstName} ${client.lastName.charAt(0)}.` : 'Unknown';
        // Use the schedule status as a chip class to color chips by status
        const statusClass = (['scheduled','in_progress','completed','cancelled','rescheduled'].includes(schedule.status) ? schedule.status : 'scheduled');
        
        html += `<div class="job-chip ${statusClass}" draggable="true" data-schedule-id="${schedule.id}" onclick="event.stopPropagation(); viewSchedule('${schedule.id}')" title="${client?.firstName || ''} ${client?.lastName || ''} - Drag to duplicate">${clientName}</div>`;
      });
      
      if (sorted.length > maxShow) {
        html += `<div class="more-jobs">+${sorted.length - maxShow} more</div>`;
      }
      
      return html;
    }

    function renderWeekView() {
      const header = document.getElementById('weekHeader');
      const content = document.getElementById('weekContent');
      
      const startOfWeek = getStartOfWeek(currentDate);
      const today = formatDateStr(new Date());
      
      // Header
      let headerHtml = '<div></div>';
      for (let i = 0; i < 7; i++) {
        const date = addDays(startOfWeek, i);
        const dateStr = formatDateStr(date);
        const isToday = dateStr === today;
        headerHtml += `
          <div class="${isToday ? 'today-header' : ''}">
            <div>${i18n.getDayName(i, true)}</div>
            <div class="font-semibold">${date.getDate()}</div>
          </div>
        `;
      }
      header.innerHTML = headerHtml;
      
      // Time slots removed; showing a single column with all jobs per day sorted by route order
      
      let contentHtml = '';
      // Create a single row with 7 day columns, listing all jobs per day sorted by route order
      contentHtml += `<div class="time-slot-row">`;
      contentHtml += `<div class="time-label"></div>`;
      for (let i = 0; i < 7; i++) {
        const date = addDays(startOfWeek, i);
        const dateStr = formatDateStr(date);

        let daySchedules = schedules.filter(s => s.date === dateStr);
        if (teamFilter) daySchedules = daySchedules.filter(s => s.teamId === teamFilter);
        const sortedDaySchedules = [...daySchedules].sort((a, b) => Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity));

        contentHtml += `
          <div class="time-cell" data-date="${dateStr}">
            ${sortedDaySchedules.map(s => {
              const client = clients.find(c => c.id === s.clientId);
              const clientName = client ? `${client.firstName} ${client.lastName.charAt(0)}.` : 'Unknown';
              const statusClass = (['scheduled','in_progress','completed','cancelled','rescheduled'].includes(s.status) ? s.status : 'scheduled');
              return `<div class="job-chip ${statusClass}" onclick="viewSchedule('${s.id}')" title="${clientName}">${clientName}</div>`;
            }).join('')}
          </div>
        `;
      }
      contentHtml += `</div>`;

      content.innerHTML = contentHtml;
    }

    function renderDayView() {
      const container = document.getElementById('daySchedule');
      const dateStr = formatDateStr(currentDate);

      let daySchedules = schedules.filter(s => s.date === dateStr);
      if (teamFilter) {
        daySchedules = daySchedules.filter(s => s.teamId === teamFilter);
      }

      const sortedDaySchedules = [...daySchedules].sort((a, b) => Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity));
      container.innerHTML = `
        <div class="day-section">
          <div class="day-section-title">Jobs (${sortedDaySchedules.length} jobs)</div>
          ${sortedDaySchedules.length > 0 ? sortedDaySchedules.map(s => renderJobCard(s)).join('') :
            `<div class="text-gray-500 text-center p-4">No jobs scheduled</div>`}
        </div>
      `;

      // Initialize drag and drop for route reordering in day view
      setTimeout(() => initRouteReordering(), 0);
    }

    function renderJobCard(schedule) {
      const client = clients.find(c => c.id === schedule.clientId);
      const team = teams.find(t => t.id === schedule.teamId);

      if (!client) return '';

      const statusClasses = {
        scheduled: 'scheduled',
        in_progress: 'in_progress',
        completed: 'completed',
        cancelled: 'cancelled',
        rescheduled: 'rescheduled'
      };

      return `
        <div class="job-card" data-schedule-id="${schedule.id}" data-team-id="${schedule.teamId || ''}" onclick="event.stopPropagation(); viewSchedule('${schedule.id}')">
          <div class="job-card-content">
            <div class="flex items-center">
              <span class="route-order ${schedule.routeOrder === 1 ? 'first' : ''}" style="cursor: grab;">${schedule.routeOrder ? schedule.routeOrder : ''}</span>
              <div class="job-card-client">${client.firstName} ${client.lastName}</div>
            </div>
            <div class="job-card-address">${client.address?.street || ''}, ${client.address?.city || ''}</div>
            <div class="job-card-details">
              <span class="badge badge-primary">
                ${getServiceSummary(client)}
              </span>
              <span class="status-badge ${statusClasses[schedule.status] || 'scheduled'}">
                ${i18n.t(`jobStatus.${schedule.status}`) || schedule.status}
              </span>
              ${team ? `<span class="job-card-detail">üë• ${team.name}</span>` : ''}
              <span class="job-card-detail">üí∞ ${formatCurrency(schedule.serviceDetails?.totalPrice || 0)}</span>
            </div>
          </div>
        </div>
      `;
    }

    // Build a Google Maps Directions URL for a team on a date and open in a new tab
    function getTeamMapsUrl(teamId, dateStr) {
      const daySchedules = schedules.filter(s => s.date === dateStr && s.status !== 'cancelled');
      const teamSchedules = daySchedules.filter(s => (s.teamId || 'unassigned') === teamId);
      if (teamSchedules.length === 0) return null;

      const sorted = [...teamSchedules].sort((a, b) => (Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity)) || (a.clientId || '').localeCompare(b.clientId || ''));

      const coords = [];
      for (const s of sorted) {
        const client = clients.find(c => c.id === s.clientId);
        if (!client) continue;
        const ccoords = client.address?.coordinates;
        if (!ccoords) return null; // Missing coords, fail fast
        coords.push(ccoords);
      }
      if (coords.length === 0) return null;

      const startCoords = officeSettings.start?.coordinates || null;
      const endCoords = officeSettings.end?.coordinates || startCoords; // Default end to start (round trip)
      const origin = startCoords ? `${startCoords.lat},${startCoords.lng}` : `${coords[0].lat},${coords[0].lng}`;
      const destination = endCoords ? `${endCoords.lat},${endCoords.lng}` : `${coords[coords.length - 1].lat},${coords[coords.length - 1].lng}`;

      // All client coordinates should be waypoints
      const waypointCoords = coords.map(c => `${c.lat},${c.lng}`);
      // Don't include start office as a waypoint (it's already the origin)
      if (startCoords && waypointCoords.length > 0) {
        // Remove first waypoint if it matches the start office
        const firstClientCoords = waypointCoords[0];
        // In practice, we'll include all clients and let Google Maps handle it
      }
      const waypoints = waypointCoords.length > 0 ? waypointCoords.join('|') : '';

      let url = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&travelmode=driving`;
      if (waypoints) url += `&waypoints=${encodeURIComponent(waypoints)}`;
      return url;
    }

    window.previewRouteForTeam = function(teamId, dateStr) {
      const url = getTeamMapsUrl(teamId, dateStr);
      if (!url) { showToast('warning', 'Missing Data', 'Team has no valid stops or missing coordinates'); return; }
      window.open(url, '_blank');
    };

    window.previewAllTeamRoutes = function(dateStr) {
      const daySchedules = schedules.filter(s => s.date === dateStr && s.status !== 'cancelled');
      const teamIds = Array.from(new Set(daySchedules.map(s => s.teamId || 'unassigned')));
      if (teamIds.length === 0) { showToast('info', 'No Routes', 'No scheduled teams with stops for this day'); return; }
      teamIds.forEach((tid, idx) => {
        const url = getTeamMapsUrl(tid, dateStr);
        if (url) setTimeout(() => window.open(url, '_blank'), idx * 300);
      });
    };

    // ============================================
    // SHOW DAY JOBS
    // ============================================
    window.showDayJobs = function(dateStr) {
      selectedDate = dateStr;
      
      let daySchedules = schedules.filter(s => s.date === dateStr);
      if (teamFilter) {
        daySchedules = daySchedules.filter(s => s.teamId === teamFilter);
      }

      const [year, month, day] = dateStr.split('-').map(Number);
      const date = new Date(year, month - 1, day);
      document.getElementById('dayJobsTitle').textContent = 
        `Jobs for ${formatDate(date, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}`;
      
      const content = document.getElementById('dayJobsContent');
      
      if (daySchedules.length === 0) {
        content.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÖ</div>
            <div class="empty-state-title">No jobs scheduled</div>
            <p class="text-gray-500">Click "Add Job" to schedule a cleaning for this day</p>
          </div>
        `;
      } else {
        // Group schedules by team and sort client jobs by ascending route order
        // Build mapping of teamId to schedules for the day
        const teamsMap = {};
        daySchedules.forEach(s => {
          const key = s.teamId || 'unassigned';
          if (!teamsMap[key]) teamsMap[key] = [];
          teamsMap[key].push(s);
        });

        let html = '';
        // Create a section for each active team, even if it has no jobs scheduled for today
        teams.forEach(team => {
          const group = (teamsMap[team.id] || []).slice().sort((a, b) => Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity));
          const clientCount = new Set(group.map(s => s.clientId)).size;
          html += `
            <div class="team-jobs-group mb-4">
              <div class="team-jobs-header">
                <div style="display:flex; align-items:center; gap:8px;">
                  <h4 class="mb-2" style="margin:0;">${team.name} <span class="text-gray-500" style="font-weight:normal; margin-left: 8px; font-size: 0.9rem;">(${clientCount} client${clientCount !== 1 ? 's' : ''})</span></h4>
                  <button class="btn btn-sm btn-outline" onclick="previewRouteForTeam('${team.id}', '${dateStr}')">üó∫Ô∏è Preview Route</button>
                </div>
              </div>
              <div class="team-jobs-list">
                ${group.length > 0 ? group.map(s => renderJobCard(s)).join('') : `<div class="text-gray-500 text-center p-4">No jobs scheduled for this team</div>`}
              </div>
            </div>
          `;
        });

        // Also include a section for unassigned jobs
        const unassignedGroup = (teamsMap['unassigned'] || []).slice().sort((a, b) => Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity));
        if (unassignedGroup.length > 0) {
          const unassignedCount = new Set(unassignedGroup.map(s => s.clientId)).size;
          html += `
            <div class="team-jobs-group mb-4">
              <div class="team-jobs-header">
                <div style="display:flex; align-items:center; gap:8px;">
                  <h4 class="mb-2" style="margin:0;">Unassigned <span class="text-gray-500" style="font-weight:normal; margin-left: 8px; font-size: 0.9rem;">(${unassignedCount} client${unassignedCount !== 1 ? 's' : ''})</span></h4>
                  <button class="btn btn-sm btn-outline" onclick="previewRouteForTeam('unassigned', '${dateStr}')">üó∫Ô∏è Preview Route</button>
                </div>
              </div>
              <div class="team-jobs-list">${unassignedGroup.map(s => renderJobCard(s)).join('')}</div>
            </div>
          `;
        }
        content.innerHTML = html;
      }

      openModal('dayJobsModal');
      // Initialize drag and drop for route reordering
      setTimeout(() => initRouteReordering(), 0);
    };

    // ============================================
    // DRAG AND DROP (Desktop + Touch)
    // ============================================
    let draggedScheduleId = null;
    let isDragCopy = false;
    let touchDragElement = null;
    let touchDragClone = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let touchMoved = false;

    function initDragAndDrop() {
      // Desktop drag and drop
      document.querySelectorAll('.job-chip[data-schedule-id]').forEach(chip => {
        chip.draggable = true;
        
        chip.addEventListener('dragstart', handleDragStart);
        chip.addEventListener('dragend', handleDragEnd);
        
        // Touch events for mobile
        chip.addEventListener('touchstart', handleTouchStart, { passive: false });
        chip.addEventListener('touchmove', handleTouchMove, { passive: false });
        chip.addEventListener('touchend', handleTouchEnd);
      });
      
      // Drop targets
      const dropTargets = document.querySelectorAll('.calendar-cell[data-date], .week-grid [data-date]');
      dropTargets.forEach(cell => {
        cell.addEventListener('dragover', handleDragOver);
        cell.addEventListener('dragleave', handleDragLeave);
        cell.addEventListener('drop', handleDrop);
      });
    }

    // Desktop handlers
    function handleDragStart(e) {
      draggedScheduleId = this.dataset.scheduleId;
      isDragCopy = true; // Always copy on drag
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('text/plain', draggedScheduleId);
    }

    function handleDragEnd(e) {
      this.classList.remove('dragging');
      clearDropHighlights();
      draggedScheduleId = null;
      isDragCopy = false;
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      this.classList.remove('drag-over', 'drag-over-copy');
      this.classList.add('drag-over-copy');
    }

    function handleDragLeave(e) {
      this.classList.remove('drag-over', 'drag-over-copy');
    }

    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over', 'drag-over-copy');

      const scheduleId = e.dataTransfer.getData('text/plain');
      const newDate = this.dataset.date;

      if (scheduleId && newDate) {
        handleScheduleDrop(scheduleId, newDate, true); // Always copy
      }
    }

    // Touch handlers for mobile
    function handleTouchStart(e) {
      if (e.touches.length !== 1) return;
      
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchMoved = false;
      touchDragElement = this;
      
      // Long press to initiate drag (300ms)
      this.touchTimeout = setTimeout(() => {
        if (touchDragElement) {
          initiateTouchDrag(e);
        }
      }, 300);
    }

    function initiateTouchDrag(e) {
      if (!touchDragElement) return;
      
      draggedScheduleId = touchDragElement.dataset.scheduleId;
      touchDragElement.classList.add('touch-dragging');
      
      // Create floating clone
      touchDragClone = touchDragElement.cloneNode(true);
      touchDragClone.style.cssText = `
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        opacity: 0.9;
        transform: scale(1.1);
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        left: ${touchStartX - 50}px;
        top: ${touchStartY - 20}px;
        width: ${touchDragElement.offsetWidth}px;
      `;
      document.body.appendChild(touchDragClone);
      
      // Vibrate if supported
      if (navigator.vibrate) navigator.vibrate(50);
      
      // Prevent scrolling
      document.body.style.overflow = 'hidden';
    }

    function handleTouchMove(e) {
      if (!touchDragElement) return;
      
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY);
      
      // If moved before long press, cancel drag initiation
      if (!touchDragClone && (deltaX > 10 || deltaY > 10)) {
        clearTimeout(touchDragElement.touchTimeout);
        touchDragElement = null;
        return;
      }
      
      // If dragging, move clone and highlight targets
      if (touchDragClone) {
        e.preventDefault();
        touchMoved = true;
        
        touchDragClone.style.left = `${touch.clientX - 50}px`;
        touchDragClone.style.top = `${touch.clientY - 20}px`;
        
        // Find drop target under finger
        const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        highlightTouchDropTarget(elemBelow);
      }
    }

    function handleTouchEnd(e) {
      clearTimeout(this.touchTimeout);
      
      if (touchDragClone && touchMoved) {
        // Find drop target
        const touch = e.changedTouches[0];
        const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        const dropTarget = findDropTarget(elemBelow);
        
        if (dropTarget && draggedScheduleId) {
          const newDate = dropTarget.dataset.date;
          if (newDate) {
            handleScheduleDrop(draggedScheduleId, newDate, false);
          }
        }
      }
      
      // Cleanup
      cleanupTouchDrag();
    }

    function findDropTarget(element) {
      if (!element) return null;
      
      // Check if element or parent is a valid drop target
      let current = element;
      while (current && current !== document.body) {
        if (current.dataset && current.dataset.date) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }

    function highlightTouchDropTarget(element) {
      clearDropHighlights();
      
      const dropTarget = findDropTarget(element);
      if (dropTarget) {
        dropTarget.classList.add('touch-drag-over');
      }
    }

    function clearDropHighlights() {
      document.querySelectorAll('.drag-over, .drag-over-copy, .touch-drag-over').forEach(el => {
        el.classList.remove('drag-over', 'drag-over-copy', 'touch-drag-over');
      });
    }

    function cleanupTouchDrag() {
      if (touchDragElement) {
        touchDragElement.classList.remove('touch-dragging');
      }
      if (touchDragClone && touchDragClone.parentNode) {
        touchDragClone.parentNode.removeChild(touchDragClone);
      }
      
      clearDropHighlights();
      
      touchDragElement = null;
      touchDragClone = null;
      draggedScheduleId = null;
      touchMoved = false;
      document.body.style.overflow = '';
    }

    // ============================================
    // ROUTE REORDERING (Drag and Drop within day)
    // ============================================
    let draggedJobCardId = null;
    let draggedJobCardTeamId = null;

    function initRouteReordering() {
      // Make job cards draggable for route reordering
      document.querySelectorAll('.job-card[data-schedule-id]').forEach(card => {
        card.draggable = true;
        card.addEventListener('dragstart', handleJobCardDragStart);
        card.addEventListener('dragend', handleJobCardDragEnd);
      });

      // Drop zones for reordering
      document.querySelectorAll('.job-card[data-schedule-id]').forEach(card => {
        card.addEventListener('dragover', handleJobCardDragOver);
        card.addEventListener('drop', handleJobCardDrop);
        card.addEventListener('dragleave', handleJobCardDragLeave);
      });
    }

    function handleJobCardDragStart(e) {
      draggedJobCardId = this.dataset.scheduleId;
      draggedJobCardTeamId = this.dataset.teamId || '';
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedJobCardId);
    }

    function handleJobCardDragEnd(e) {
      this.classList.remove('dragging');
      clearDropHighlights();
      draggedJobCardId = null;
      draggedJobCardTeamId = null;
    }

    function handleJobCardDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      if (this.dataset.scheduleId !== draggedJobCardId) {
        this.classList.add('drag-over');
      }
    }

    function handleJobCardDragLeave(e) {
      this.classList.remove('drag-over');
    }

    async function handleJobCardDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over');

      const targetScheduleId = this.dataset.scheduleId;
      const targetTeamId = this.dataset.teamId || '';

      if (draggedJobCardId === targetScheduleId) return;
      if (draggedJobCardTeamId !== targetTeamId) return; // Can only reorder within same team

      // Get all schedules for this team on this date
      const draggedSchedule = schedules.find(s => s.id === draggedJobCardId);
      const targetSchedule = schedules.find(s => s.id === targetScheduleId);

      if (!draggedSchedule || !targetSchedule) return;

      const dateStr = draggedSchedule.date;
      const teamId = draggedJobCardTeamId || '';

      const dayTeamSchedules = schedules
        .filter(s => s.date === dateStr && (s.teamId || '') === teamId && s.status !== 'cancelled')
        .sort((a, b) => Number(a.routeOrder || Infinity) - Number(b.routeOrder || Infinity));

      const draggedIdx = dayTeamSchedules.findIndex(s => s.id === draggedJobCardId);
      const targetIdx = dayTeamSchedules.findIndex(s => s.id === targetScheduleId);

      if (draggedIdx === -1 || targetIdx === -1) return;

      // Reorder: remove dragged, insert at target
      const reordered = [...dayTeamSchedules];
      const [removed] = reordered.splice(draggedIdx, 1);
      reordered.splice(targetIdx, 0, removed);

      // Update routeOrder for all affected schedules
      try {
        for (let i = 0; i < reordered.length; i++) {
          const schedule = reordered[i];
          if (schedule.routeOrder !== i + 1) {
            await updateDoc(doc(db, 'schedules', schedule.id), {
              routeOrder: i + 1,
              updatedAt: Timestamp.now()
            });
          }
        }

        showToast('success', 'Route Updated', 'Job order updated');
        await loadSchedules();
        if (selectedDate === dateStr) showDayJobs(dateStr);
      } catch (error) {
        console.error('Error updating route order:', error);
        showToast('error', 'Error', 'Failed to update route order');
      }
    }

    async function handleScheduleDrop(scheduleId, newDate, isCopy) {
      const schedule = schedules.find(s => s.id === scheduleId);
      if (!schedule) return;

      // Don't do anything if dropping on the same date (for move)
      if (!isCopy && schedule.date === newDate) return;
      
      const client = clients.find(c => c.id === schedule.clientId);
      
      // Check for duplicate client on the target date
      const existingOnDate = schedules.find(s => 
        s.clientId === schedule.clientId && 
        s.date === newDate && 
        s.id !== scheduleId
      );
      
      if (existingOnDate) {
        showToast('warning', 'Duplicate', `${client?.firstName || ''} ${client?.lastName || ''} is already scheduled for ${newDate}`);
        return;
      }
      
      // Determine status based on date
      const today = formatDateStr(new Date());
      const newStatus = newDate >= today ? 'scheduled' : schedule.status;
      
      try {
        if (isCopy) {
          // Create a new schedule (copy)
          const newScheduleData = {
            clientId: schedule.clientId,
            teamId: schedule.teamId || '',
            date: newDate,
            serviceDetails: { ...schedule.serviceDetails },
            estimatedDuration: schedule.estimatedDuration || 2,
            status: newStatus,
            notes: schedule.notes || '',
            routeOrder: 0,
            createdAt: Timestamp.now(),
            updatedAt: Timestamp.now()
          };
          
          const docRef = await addDoc(collection(db, 'schedules'), newScheduleData);
          await logScheduleAction(AuditActions.CREATE, docRef.id, 
            `Copied ${client?.firstName || ''} ${client?.lastName || ''} to ${newDate}`);
          showToast('success', 'Copied', `Job copied to ${newDate}`);
        } else {
          // Update existing schedule (move)
          await updateDoc(doc(db, 'schedules', scheduleId), {
            date: newDate,
            status: newStatus,
            routeOrder: 0,
            updatedAt: Timestamp.now()
          });
          await logScheduleAction(AuditActions.UPDATE, scheduleId, 
            `Moved ${client?.firstName || ''} ${client?.lastName || ''} to ${newDate}`);
          showToast('success', 'Moved', `Job moved to ${newDate}`);
        }
        
        await loadSchedules();
        renderCalendar();
      } catch (error) {
        
        showToast('error', 'Error', `Failed to ${isCopy ? 'copy' : 'move'} job`);
      }
    }

    // ============================================
    // SCHEDULE CRUD
    // ============================================
    function openAddScheduleModal(dateStr = null) {
      editingScheduleId = null;
      selectedClient = null;
      document.getElementById('scheduleModalTitle').textContent = i18n.t('scheduleJob');
      document.getElementById('scheduleForm').reset();
      document.getElementById('clientPreview').classList.add('hidden');
      
      if (dateStr) {
        document.getElementById('scheduleDate').value = dateStr;
      } else {
        document.getElementById('scheduleDate').value = formatDateStr(new Date());
      }
      
      document.getElementById('scheduleStatus').value = 'scheduled';
      // Clear client search and default the team to the first team (if available)
      const clientSearchInput = document.getElementById('scheduleClientSearch');
      if (clientSearchInput) clientSearchInput.value = '';
      if (!editingScheduleId && teams && teams.length > 0) document.getElementById('scheduleTeam').value = teams[0].id;
      updateTotalPrice();
      openModal('scheduleModal');
    }

    window.viewSchedule = async function(id) {
      // Close dayJobsModal first if open to prevent z-index issues
      closeModal('dayJobsModal');
      
      const schedule = schedules.find(s => s.id === id);
      if (!schedule) return;
      
      const client = clients.find(c => c.id === schedule.clientId);
      const team = teams.find(t => t.id === schedule.teamId);
      
      const statusColors = {
        scheduled: 'scheduled',
        in_progress: 'in_progress',
        completed: 'completed',
        cancelled: 'cancelled',
        rescheduled: 'rescheduled'
      };
      
      const [year, month, day] = schedule.date.split('-').map(Number);
      const date = new Date(year, month - 1, day);
      
      document.getElementById('viewScheduleContent').innerHTML = `
        <div class="flex justify-between items-start mb-6">
          <div>
            <h2 class="text-2xl font-semibold">${client?.firstName || ''} ${client?.lastName || 'Unknown Client'}</h2>
            <div class="text-gray-500">${client?.address?.street || ''}</div>
            <div class="text-gray-500">${client?.address?.city || ''}, ${client?.address?.state || ''} ${client?.address?.zip || ''}</div>
            ${client?.houseCode ? `<div class="text-gray-500 mt-1">üîë ${client.houseCode}</div>` : ''}
          </div>
          <span class="status-badge ${statusColors[schedule.status] || 'pending'}">
            ${i18n.t(`jobStatus.${schedule.status}`) || schedule.status}
          </span>
        </div>
        
        <div class="grid grid-cols-2 gap-6 mb-6">
          <div class="card">
            <div class="card-body">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <div class="text-sm text-gray-500">${i18n.t('date')}</div>
                  <div class="font-semibold">${formatDate(date, { weekday: 'short', month: 'short', day: 'numeric' })}</div>
                </div>
                <div>
                  <div class="text-sm text-gray-500">Route</div>
                  <div class="font-semibold">${schedule.routeOrder ? ('#' + schedule.routeOrder) : '‚Äî'}</div>
                </div>
                <div>
                  <div class="text-sm text-gray-500">${i18n.t('team')}</div>
                  <div class="font-semibold">${team?.name || 'Unassigned'}</div>
                </div>
                <div>
                  <div class="text-sm text-gray-500">${i18n.t('estimatedDuration')}</div>
                  <div class="font-semibold">${schedule.estimatedDuration || 2} ${i18n.t('hours')}</div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="card">
            <div class="card-body">
              ${schedule.serviceDetails?.addOns?.length > 0 ? `
                <div class="text-sm text-gray-500 mb-2">${i18n.t('addOns')}</div>
                <div class="flex flex-col gap-1 mb-3">
                  ${schedule.serviceDetails.addOns.map(a => {
                    const label = typeof a === 'object' ? a.area : a;
                    const price = typeof a === 'object' ? a.price : 0;
                    const floorLabels = { basement: 'üèöÔ∏è Basement', mainLevel: 'üè† Main Level', upstairs: '‚¨ÜÔ∏è Upstairs' };
                    return `<span class="badge badge-secondary">${floorLabels[label] || label}${price ? ' (+' + formatCurrency(price) + ')' : ''}</span>`;
                  }).join('')}
                </div>
              ` : ''}
              
              <div class="pt-3 border-t">
                <div class="flex justify-between items-center">
                  <span class="text-gray-500">${i18n.t('total')}</span>
                  <span class="text-2xl font-bold text-primary">${formatCurrency(schedule.serviceDetails?.totalPrice || 0)}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        ${schedule.notes ? `
          <div class="card">
            <div class="card-body">
              <div class="text-sm text-gray-500 mb-1">${i18n.t('notes')}</div>
              <p>${schedule.notes}</p>
            </div>
          </div>
        ` : ''}
      `;
      
      document.getElementById('editScheduleBtn').onclick = () => {
        closeModal('viewScheduleModal');
        editSchedule(id);
      };
      
      document.getElementById('deleteScheduleBtn').onclick = () => {
        deleteSchedule(id);
      };
      
      openModal('viewScheduleModal');
    };

    window.editSchedule = async function(id) {
      const schedule = schedules.find(s => s.id === id);
      if (!schedule) return;
      
      editingScheduleId = id;
      document.getElementById('scheduleModalTitle').textContent = i18n.t('editSchedule');
      
      document.getElementById('scheduleClient').value = schedule.clientId;
      // Populate and set the search input to the selected client label
      const clientSearchInput = document.getElementById('scheduleClientSearch');
      const client = clients.find(c => c.id === schedule.clientId);
      if (clientSearchInput) clientSearchInput.value = client ? `${client.lastName}, ${client.firstName} - ${client.address?.street || ''}` : '';
      document.getElementById('scheduleTeam').value = schedule.teamId;
      document.getElementById('scheduleDate').value = schedule.date;
      // Time slot no longer used. Keep hidden input empty for compatibility.
      document.getElementById('scheduleTimeSlot').value = '';
      document.getElementById('scheduleDuration').value = schedule.estimatedDuration || 2;
      document.getElementById('scheduleStatus').value = schedule.status;
      document.getElementById('scheduleNotes').value = schedule.notes || '';
      
      // Update client preview (this builds the add-ons)
      onClientChange();
      
      // Set addons from saved schedule
      const savedAddOns = schedule.serviceDetails?.addOns || [];
      setTimeout(() => {
        document.querySelectorAll('.addon-checkbox').forEach(checkbox => {
          const areaKey = checkbox.dataset.area;
          // Support both old format (string array) and new format (object array)
          const isChecked = savedAddOns.some(a =>
            (typeof a === 'string' && a === areaKey) ||
            (typeof a === 'object' && a.area === areaKey)
          );
          checkbox.checked = isChecked;
        });
      }, 100);
      
      updateTotalPrice();
      openModal('scheduleModal');
    };

    async function saveSchedule() {
      const clientId = document.getElementById('scheduleClient').value;
      let teamId = document.getElementById('scheduleTeam').value;
      const date = document.getElementById('scheduleDate').value;
      
      if (!clientId || !date) {
        showToast('error', i18n.t('error'), i18n.t('required'));
        return;
      }
      // Check for duplicate client on the same date (excluding current schedule being edited)

      const duplicateSchedule = schedules.find(s => 
        s.clientId === clientId && 
        s.date === date && 
        s.id !== editingScheduleId
      );

      if (duplicateSchedule) {
        const client = clients.find(c => c.id === clientId);
        showToast('warning', 'Duplicate', `${client?.firstName || ''} ${client?.lastName || ''} is already scheduled for ${date}`);
        return;
      }

      // Default the team to the first available team if none selected
      if (!teamId && teams && teams.length > 0) teamId = teams[0].id;
      
      const client = clients.find(c => c.id === clientId);
      
      // Calculate total price from base + add-ons
      let totalPrice = client?.basePrice || 0;
      const addOns = [];

      document.querySelectorAll('.addon-checkbox:checked').forEach(checkbox => {
        const areaKey = checkbox.dataset.area;
        const price = parseFloat(checkbox.dataset.price) || 0;
        const frequency = checkbox.dataset.frequency || 'monthly';
        addOns.push({ area: areaKey, price: price, frequency: frequency });
        totalPrice += price;
      });
      
const scheduleData = {
        clientId,
        teamId,
        date,
        // timeSlot removed -- schedules no longer track a time slot
        serviceDetails: {
          addOns,
          totalPrice
        },
        estimatedDuration: parseFloat(document.getElementById('scheduleDuration').value),
        status: document.getElementById('scheduleStatus').value,
        notes: document.getElementById('scheduleNotes').value.trim(),
        updatedAt: Timestamp.now()
      };
      
      try {
        if (editingScheduleId) {
          await updateDoc(doc(db, 'schedules', editingScheduleId), scheduleData);
          await logScheduleAction(AuditActions.UPDATE, editingScheduleId, 
            `${client.firstName} ${client.lastName} - ${date}`);
          showToast('success', i18n.t('success'), i18n.t('scheduleUpdated'));
        } else {
          scheduleData.createdAt = Timestamp.now();
          const docRef = await addDoc(collection(db, 'schedules'), scheduleData);
          await logScheduleAction(AuditActions.CREATE, docRef.id, 
            `${client.firstName} ${client.lastName} - ${date}`);
          showToast('success', i18n.t('success'), i18n.t('scheduleCreated'));
        }
        
        closeModal('scheduleModal');
        closeModal('dayJobsModal');
        await loadSchedules();
        renderCalendar();
      } catch (error) {
        
        showToast('error', i18n.t('error'), 'Failed to save schedule');
      }
    }

    async function deleteSchedule(id) {
      const schedule = schedules.find(s => s.id === id);
      if (!schedule) return;
      
      const client = clients.find(c => c.id === schedule.clientId);
      
      const confirmed = await confirmDialog(
        i18n.t('delete'),
        i18n.t('confirmDeleteSchedule'),
        i18n.t('delete'),
        i18n.t('cancel')
      );
      
      if (!confirmed) return;
      
      try {
        await deleteDoc(doc(db, 'schedules', id));
        await logScheduleAction(AuditActions.DELETE, id, 
          `${client?.firstName || ''} ${client?.lastName || ''} - ${schedule.date}`);
        showToast('success', i18n.t('success'), i18n.t('scheduleDeleted'));
        
        closeModal('viewScheduleModal');
        closeModal('dayJobsModal');
        await loadSchedules();
        renderCalendar();
      } catch (error) {
        
        showToast('error', i18n.t('error'), 'Failed to delete schedule');
      }
    }

    async function deleteAllDaySchedules(dateStr) {
      const daySchedules = schedules.filter(s => s.date === dateStr);
      
      if (daySchedules.length === 0) {
        showToast('info', 'No Jobs', 'No jobs to delete for this day');
        return;
      }
      
      const confirmed = await confirmDialog(
        'Delete All Jobs',
        `Are you sure you want to delete all ${daySchedules.length} job(s) scheduled for this day? This cannot be undone.`,
        'Delete All',
        'Cancel'
      );
      
      if (!confirmed) return;
      
      // Show loading state
      const deleteBtn = document.getElementById('deleteAllDayJobsBtn');
      const originalHTML = deleteBtn.innerHTML;
      deleteBtn.disabled = true;
      deleteBtn.innerHTML = '<span class="spinner spinner-danger"></span> Deleting...';
      
      // Also disable other footer buttons to prevent conflicts
      const footerBtns = document.querySelectorAll('#dayJobsModal .modal-footer .btn');
      footerBtns.forEach(btn => btn.disabled = true);
      
      try {
        let deleted = 0;
        for (const schedule of daySchedules) {
          await deleteDoc(doc(db, 'schedules', schedule.id));
          deleted++;
        }
        
        await logScheduleAction(AuditActions.DELETE, null, `Bulk deleted ${deleted} schedules for ${dateStr}`);
        showToast('success', i18n.t('success'), `${deleted} jobs deleted`);
        
        closeModal('dayJobsModal');
        await loadSchedules();
        renderCalendar();
      } catch (error) {
        
        showToast('error', i18n.t('error'), 'Failed to delete schedules');
      } finally {
        // Reset button states
        deleteBtn.disabled = false;
        deleteBtn.innerHTML = originalHTML;
        footerBtns.forEach(btn => btn.disabled = false);
      }
    }

    // ============================================
    // AUTO-SCHEDULE GENERATION
    // ============================================
    let selectedWeekStart = null;

    function openAutoScheduleModal() {
      // Find next Monday
      const today = new Date();
      let nextMonday = new Date(today);
      const dayOfWeek = today.getDay();
      const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);
      nextMonday = addDays(today, daysUntilMonday);
      
      selectedWeekStart = nextMonday;
      updateWeekSelector();
      
      // Populate team select
      const teamSelect = document.getElementById('autoDefaultTeam');
      teamSelect.innerHTML = '<option value="">Auto-assign (distribute by proximity)</option>' +
        teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
      
      estimateJobs();
      openModal('autoScheduleModal');
    }

    function updateWeekSelector() {
      const monday = selectedWeekStart;
      const sunday = addDays(monday, 6);
      
      // Update display
      const rangeText = `${formatDate(monday, { month: 'short', day: 'numeric' })} - ${formatDate(sunday, { month: 'short', day: 'numeric', year: 'numeric' })}`;
      document.getElementById('weekRangeText').textContent = rangeText;
      
      // Update hidden inputs
      document.getElementById('autoStartDate').value = formatDateStr(monday);
      document.getElementById('autoEndDate').value = formatDateStr(sunday);
      
      estimateJobs();
    }

    function navigateWeek(direction) {
      selectedWeekStart = addDays(selectedWeekStart, direction * 7);
      updateWeekSelector();
    }

    function estimateJobs() {
      const startDate = new Date(document.getElementById('autoStartDate').value);
      const endDate = new Date(document.getElementById('autoEndDate').value);
      const filter = document.getElementById('autoClientFilter').value;

      if (isNaN(startDate) || isNaN(endDate)) {
        document.getElementById('estimatedJobs').textContent = '0';
        return;
      }

      // Include active clients with recurring schedules (regardless of schedule status)
      let eligibleClients = clients.filter(c => c.isActive && c.scheduleType !== 'oneTime');

      // Simple estimation based on schedule frequency
      let totalJobs = 0;
      const days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));

      eligibleClients.forEach(client => {
        let interval = 7;
        switch (client.scheduleType) {
          case 'weekly': interval = 7; break;
          case 'biweekly': interval = 14; break;
          case 'every3weeks': interval = 21; break;
          case 'monthly': interval = 30; break;
          default: interval = 7;
        }
        totalJobs += Math.ceil(days / interval);
      });

      document.getElementById('estimatedJobs').textContent = totalJobs;
    }

    async function generateSchedules() {
      const startDate = new Date(document.getElementById('autoStartDate').value);
      const endDate = new Date(document.getElementById('autoEndDate').value);
      const defaultTeamId = document.getElementById('autoDefaultTeam').value;
      
      if (isNaN(startDate) || isNaN(endDate)) {
        showToast('error', i18n.t('error'), 'Please select valid dates');
        return;
      }

      // Validate: max 1 week range (Mon-Sun)
      const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
      if (daysDiff > 7) {
        showToast('error', i18n.t('error'), 'Schedule generation is limited to 1 week (Monday-Sunday)');
        return;
      }

      // Show loading state
      const generateBtn = document.getElementById('generateSchedulesBtn');
      const originalText = generateBtn.textContent;
      generateBtn.disabled = true;
      generateBtn.innerHTML = '<span class="spinner"></span> Generating...';

      try {
        // Load 1-2 months of historical data to determine scheduling needs
        const twoMonthsAgo = addDays(new Date(), -60);
        const oneMonthAgo = addDays(new Date(), -30);
        
        // Query existing schedules from past 2 months to now + end date range
        const historicalStartStr = formatDateStr(twoMonthsAgo);
        const futureEndStr = formatDateStr(endDate);
        
        const q = query(
          collection(db, 'schedules'),
          where('date', '>=', historicalStartStr),
          where('date', '<=', futureEndStr)
        );
        const snapshot = await getDocs(q);
        const allSchedules = [];
        snapshot.forEach(doc => allSchedules.push({ id: doc.id, ...doc.data() }));
        // Filter to active clients with recurring schedules and some history (regardless of schedule status)
        const eligibleClients = clients.filter(c => {
          if (!c.isActive) return false;
          if (!c.scheduleType || c.scheduleType === 'oneTime') return false;

          // Check if client has any schedule history in the past 2 months
          const hasHistory = allSchedules.some(s => s.clientId === c.id);
          return hasHistory;
        });

        if (eligibleClients.length === 0) {
          showToast('warning', 'No Clients', 'No recurring clients with schedule history found. Clients need at least one past schedule to auto-generate.');
          return;
        }

        // Collect all new schedules to create (grouped by date for distribution)
        const schedulesToCreate = {}; // dateStr -> array of schedule data
        
        for (const client of eligibleClients) {
          // Calculate interval based on schedule type
          let interval = 7;
          switch (client.scheduleType) {
            case 'weekly': interval = 7; break;
            case 'biweekly': interval = 14; break;
            case 'every3weeks': interval = 21; break;
            case 'monthly': interval = 30; break;
            case 'custom': interval = client.customScheduleDays || 30; break;
          }
          
          // Find last service date for this client (from historical data)
          const clientHistory = allSchedules
            .filter(s => s.clientId === client.id && s.status !== 'cancelled')
            .sort((a, b) => b.date.localeCompare(a.date));
          
          let nextServiceDate;
          
          if (clientHistory.length > 0) {
            // Calculate next service date based on last service
            const lastServiceDate = new Date(clientHistory[0].date + 'T00:00:00');
            nextServiceDate = addDays(lastServiceDate, interval);
          } else {
            // No history - start from the beginning of the range
            nextServiceDate = new Date(startDate);
          }
          
          // Adjust to preferred day if set
          if (client.preferredDay) {
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const targetDay = dayMap[client.preferredDay];
            while (nextServiceDate.getDay() !== targetDay) {
              nextServiceDate = addDays(nextServiceDate, 1);
            }
          }
          
          // Generate schedules within the date range
          while (nextServiceDate <= endDate) {
            if (nextServiceDate >= startDate) {
              const dateStr = formatDateStr(nextServiceDate);
              
              // Check if already scheduled for this date
              const existing = allSchedules.find(s => s.clientId === client.id && s.date === dateStr);
              
              // Check for duplicate - client already scheduled for this date in our pending list
              const pendingDuplicate = schedulesToCreate[dateStr]?.find(s => s.clientId === client.id);
              if (!existing && !pendingDuplicate) {
                // Calculate total price from base
                const totalPrice = client.basePrice || 0;
                
                // Build areas list from client's included floors
                const includedAreas = [];
                if (client.areas?.basement?.includedInBase) includedAreas.push('basement');
                if (client.areas?.mainLevel?.includedInBase) includedAreas.push('mainLevel');
                if (client.areas?.upstairs?.includedInBase) includedAreas.push('upstairs');
                
                const scheduleData = {
                  clientId: client.id,
                  client: client, // Keep reference for distribution
                  date: dateStr,
                  serviceDetails: {
                    areas: includedAreas,
                    addOns: [],
                    totalPrice
                  },
                  estimatedDuration: 2,
                  status: 'scheduled',
                  notes: '',
                  createdAt: Timestamp.now(),
                  updatedAt: Timestamp.now()
                };
                
                if (!schedulesToCreate[dateStr]) schedulesToCreate[dateStr] = [];
                schedulesToCreate[dateStr].push(scheduleData);
              }
            }
            
            nextServiceDate = addDays(nextServiceDate, interval);
          }
        }
        
        // Now distribute and create schedules per day (similar to distributeAndRouteDay)
        let created = 0;
        const activeTeams = teams.filter(t => t.isActive !== false);
        
        for (const [dateStr, daySchedules] of Object.entries(schedulesToCreate)) {
          if (daySchedules.length === 0) continue;

          // Sort clients by proximity, then distribute evenly across teams
          const dayClients = daySchedules.map(s => s.client).filter(c => c);
          const sortedClients = sortClientsByProximity(dayClients);

          // Distribute clients evenly across teams (4-3-3 pattern for balance)
          const teamAssignments = {};
          activeTeams.forEach(t => teamAssignments[t.id] = []);

          const jobsPerTeam = Math.floor(sortedClients.length / activeTeams.length);
          const remainder = sortedClients.length % activeTeams.length;

          sortedClients.forEach((client, idx) => {
            // Distribute jobs: first `remainder` teams get jobsPerTeam + 1 jobs
            let teamIdx = 0;
            let currentIdx = 0;
            for (let i = 0; i < activeTeams.length; i++) {
              const jobsForThisTeam = jobsPerTeam + (i < remainder ? 1 : 0);
              if (idx < currentIdx + jobsForThisTeam) {
                teamIdx = i;
                break;
              }
              currentIdx += jobsForThisTeam;
            }
            teamAssignments[activeTeams[teamIdx].id].push(client);
          });
          
          // Create schedules with team assignments and route order
          for (const [teamId, teamClients] of Object.entries(teamAssignments)) {
            const optimized = sortClientsByProximity(teamClients);
            for (let i = 0; i < optimized.length; i++) {
              const client = optimized[i];
              const scheduleData = daySchedules.find(s => s.clientId === client.id);
              if (scheduleData) {
                // Remove temporary client reference and add team info
                delete scheduleData.client;
                scheduleData.teamId = teamId;
                scheduleData.routeOrder = i + 1;
                
                try {
                  await addDoc(collection(db, 'schedules'), scheduleData);
                  created++;
                } catch (error) {
                  
                }
              }
            }
          }
          
          // Handle case with no teams - create without team assignment
          if (activeTeams.length === 0) {
            for (const scheduleData of daySchedules) {
              delete scheduleData.client;
              scheduleData.teamId = '';
              scheduleData.routeOrder = 0;
              try {
                await addDoc(collection(db, 'schedules'), scheduleData);
                created++;
              } catch (error) {
                
              }
            }
          }
        }
        
        await logScheduleAction(AuditActions.CREATE, null, `Auto-generated ${created} schedules`);
        showToast('success', i18n.t('success'), `${created} schedules created`);
        
        closeModal('autoScheduleModal');
        await loadSchedules();
        renderCalendar();
        
      } catch (error) {
        
        showToast('error', i18n.t('error'), 'Failed to generate schedules');
      } finally {
        // Reset button state
        generateBtn.disabled = false;
        generateBtn.textContent = originalText;
      }
    }

    function shouldScheduleClient(client, dateStr) {
      const clientHistory = historicalSchedules
        .filter(s => s.clientId === client.id)
        .sort((a, b) => b.date.localeCompare(a.date));
      
      if (clientHistory.length === 0) return true;
      
      const lastDate = new Date(clientHistory[0].date);
      const targetDate = new Date(dateStr);
      const daysSince = Math.floor((targetDate - lastDate) / (1000 * 60 * 60 * 24));
      
      let interval = 7;
      switch (client.scheduleType) {
        case 'weekly': interval = 7; break;
        case 'biweekly': interval = 14; break;
        case 'every3weeks': interval = 21; break;
        case 'monthly': interval = 30; break;
        case 'custom': interval = client.customScheduleDays || 30; break;
      }
      
      return daysSince >= (interval - 3);
    }

    // ============================================
    // GEOGRAPHIC CLUSTERING
    // ============================================
    /**
     * Group clients into geographic clusters using a simple k-means-like algorithm.
     * This helps balance workloads by geography rather than just proximity.
     */
    function clusterClientsByGeography(clientList, numClusters = 3) {
      if (clientList.length <= numClusters) return clientList.map(c => [c]);

      // Filter clients with coordinates
      const withCoords = clientList.filter(c => c.address?.coordinates);
      const withoutCoords = clientList.filter(c => !c.address?.coordinates);

      if (withCoords.length === 0) return [clientList];

      // Simple k-means clustering
      // 1. Initialize cluster centers with random clients
      const centers = [];
      const indices = [];
      for (let i = 0; i < Math.min(numClusters, withCoords.length); i++) {
        const randomIdx = Math.floor(Math.random() * withCoords.length);
        if (!indices.includes(randomIdx)) {
          indices.push(randomIdx);
          centers.push(withCoords[randomIdx].address.coordinates);
        }
      }

      // If we couldn't get enough random centers, use the first ones
      while (centers.length < numClusters && centers.length < withCoords.length) {
        const idx = centers.length;
        if (idx < withCoords.length) {
          centers.push(withCoords[idx].address.coordinates);
        }
      }

      // 2. Assign clients to nearest cluster center (iterate a few times for convergence)
      let clusters = Array(centers.length).fill(null).map(() => []);
      for (let iteration = 0; iteration < 3; iteration++) {
        clusters = Array(centers.length).fill(null).map(() => []);

        withCoords.forEach(client => {
          const coords = client.address.coordinates;
          let nearestCenter = 0;
          let nearestDist = Infinity;

          centers.forEach((center, idx) => {
            const dist = haversineDistance(coords, center);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestCenter = idx;
            }
          });

          clusters[nearestCenter].push(client);
        });

        // Update centers to be the centroid of each cluster
        clusters.forEach((cluster, idx) => {
          if (cluster.length > 0) {
            let sumLat = 0, sumLng = 0;
            cluster.forEach(c => {
              sumLat += c.address.coordinates.lat;
              sumLng += c.address.coordinates.lng;
            });
            centers[idx] = {
              lat: sumLat / cluster.length,
              lng: sumLng / cluster.length
            };
          }
        });
      }

      // Remove empty clusters and add clients without coordinates to the last cluster
      const result = clusters.filter(cluster => cluster.length > 0);
      if (result.length > 0) {
        result[result.length - 1] = [...result[result.length - 1], ...withoutCoords];
      } else if (withoutCoords.length > 0) {
        result.push(withoutCoords);
      }

      return result;
    }

    // ============================================
    // PROXIMITY-BASED ROUTING
    // ============================================
    // Compute distance for a route with optional start/end legs
    function routeDistance(route, startCoords, endCoords) {
      let d = 0;
      if (route.length === 0) return 0;
      if (startCoords) d += haversineDistance(startCoords, route[0].address.coordinates);
      for (let i = 0; i < route.length - 1; i++) {
        d += haversineDistance(route[i].address.coordinates, route[i + 1].address.coordinates);
      }
      if (endCoords) d += haversineDistance(route[route.length - 1].address.coordinates, endCoords);
      return d;
    }

    // 2-opt improvement for a route (considering start & end points)
    function optimizeRouteTwoOpt(route, startCoords, endCoords) {
      if (route.length <= 2) return route;
      let improved = true;
      const copy = [...route];
      while (improved) {
        improved = false;
        for (let i = 0; i < copy.length - 1; i++) {
          for (let k = i + 1; k < copy.length; k++) {
            const newRoute = [...copy.slice(0, i), ...copy.slice(i, k + 1).reverse(), ...copy.slice(k + 1)];
            if (routeDistance(newRoute, startCoords, endCoords) + 1e-6 < routeDistance(copy, startCoords, endCoords)) {
              // Accept improved route
              copy.splice(0, copy.length, ...newRoute);
              improved = true;
            }
          }
        }
      }
      return copy;
    }

    function sortClientsByProximity(clientList) {
      // We need start coordinates; don't reorder if not available
      const startCoords = officeSettings.start?.coordinates;
      const endCoords = officeSettings.end?.coordinates || null;
      if (!startCoords) return clientList;

      const withCoords = clientList.filter(c => c.address?.coordinates);
      const withoutCoords = clientList.filter(c => !c.address?.coordinates);
      if (withCoords.length <= 1) return [...withCoords, ...withoutCoords];

      // Greedy nearest-neighbor starting at startCoords
      const sorted = [];
      let currentPoint = startCoords;
      const remaining = [...withCoords];
      while (remaining.length > 0) {
        let nearestIdx = 0;
        let nearestDist = Infinity;
        for (let i = 0; i < remaining.length; i++) {
          const clientCoords = remaining[i].address.coordinates;
          const dist = haversineDistance(currentPoint, clientCoords);
          if (dist < nearestDist) { nearestDist = dist; nearestIdx = i; }
        }
        const nearest = remaining.splice(nearestIdx, 1)[0];
        sorted.push(nearest);
        currentPoint = nearest.address.coordinates;
      }

      // If an end is provided, check whether the reversed route yields shorter total distance
      if (endCoords) {
        const reversed = [...sorted].reverse();
        const forwardDist = routeDistance(sorted, startCoords, endCoords);
        const reversedDist = routeDistance(reversed, startCoords, endCoords);
        if (reversedDist + 1e-6 < forwardDist) {
          sorted.splice(0, sorted.length, ...reversed);
        }
      }

      // Improve with 2-opt optimization (considering start & end legs)
      const optimized = optimizeRouteTwoOpt(sorted, startCoords, endCoords);

      return [...optimized, ...withoutCoords];
    }

    function haversineDistance(coord1, coord2) {
      const R = 6371;
      const dLat = toRad(coord2.lat - coord1.lat);
      const dLon = toRad(coord2.lng - coord1.lng);
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function toRad(deg) { return deg * (Math.PI / 180); }

    function assignTeamByProximity(client, dateStr) {
      if (teams.length === 0) return '';
      if (teams.length === 1) return teams[0].id;
      
      const dateSchedules = schedules.filter(s => s.date === dateStr);
      const teamLoads = {};
      const teamCentroids = {};
      
      teams.forEach(t => {
        teamLoads[t.id] = 0;
        teamCentroids[t.id] = { lat: 0, lng: 0, count: 0 };
      });
      
      dateSchedules.forEach(s => {
        if (s.teamId && teamLoads[s.teamId] !== undefined) {
          teamLoads[s.teamId]++;
          const schedClient = clients.find(c => c.id === s.clientId);
          if (schedClient?.address?.coordinates) {
            teamCentroids[s.teamId].lat += schedClient.address.coordinates.lat;
            teamCentroids[s.teamId].lng += schedClient.address.coordinates.lng;
            teamCentroids[s.teamId].count++;
          }
        }
      });
      
      const clientCoords = client.address?.coordinates;
      let bestTeam = teams[0].id;
      let bestScore = Infinity;
      
      for (const team of teams) {
        const load = teamLoads[team.id];
        const centroid = teamCentroids[team.id];
        let score;
        if (clientCoords && centroid.count > 0) {
          const avgLat = centroid.lat / centroid.count;
          const avgLng = centroid.lng / centroid.count;
          const dist = haversineDistance(clientCoords, { lat: avgLat, lng: avgLng });
          score = dist + (load * 5);
        } else {
          score = load;
        }
        if (score < bestScore) { bestScore = score; bestTeam = team.id; }
      }
      return bestTeam;
    }

    async function distributeAndRouteDay(dateStr) {
      let daySchedules = schedules.filter(s => s.date === dateStr && s.status !== 'cancelled');
      if (daySchedules.length === 0) { showToast('warning', 'No Jobs', 'No jobs to distribute'); return; }

      const activeTeams = teams.filter(t => t.isActive !== false);
      if (activeTeams.length === 0) { showToast('error', 'No Teams', 'No active teams'); return; }

      showToast('info', 'Processing', 'Distributing and optimizing routes...');

      const scheduleClients = daySchedules.map(s => {
        const client = clients.find(c => c.id === s.clientId);
        return { schedule: s, client };
      }).filter(sc => sc.client);

      // Sort clients by proximity, then distribute evenly across teams
      const allClients = scheduleClients.map(sc => sc.client);
      const sortedClients = sortClientsByProximity(allClients);

      // Distribute clients evenly across teams (4-3-3 pattern for balance)
      const teamAssignments = {};
      activeTeams.forEach(t => teamAssignments[t.id] = []);

      const jobsPerTeam = Math.floor(sortedClients.length / activeTeams.length);
      const remainder = sortedClients.length % activeTeams.length;

      sortedClients.forEach((client, idx) => {
        // Distribute jobs: first `remainder` teams get jobsPerTeam + 1 jobs
        let teamIdx = 0;
        let currentIdx = 0;
        for (let i = 0; i < activeTeams.length; i++) {
          const jobsForThisTeam = jobsPerTeam + (i < remainder ? 1 : 0);
          if (idx < currentIdx + jobsForThisTeam) {
            teamIdx = i;
            break;
          }
          currentIdx += jobsForThisTeam;
        }
        teamAssignments[activeTeams[teamIdx].id].push(client);
      });
      
      let updateCount = 0;
      for (const [teamId, teamClients] of Object.entries(teamAssignments)) {
        const optimized = sortClientsByProximity(teamClients);
        for (let i = 0; i < optimized.length; i++) {
          const client = optimized[i];
          const sc = scheduleClients.find(sc => sc.client.id === client.id);
          if (sc) {
            try {
              await updateDoc(doc(db, 'schedules', sc.schedule.id), {
                teamId: teamId, routeOrder: i + 1, updatedAt: Timestamp.now()
              });
              updateCount++;
            } catch (e) {  }
          }
        }
      }
      
      showToast('success', 'Routes Optimized', `Updated ${updateCount} jobs`);
      await loadSchedules();
      renderCalendar();
      if (selectedDate === dateStr) showDayJobs(dateStr);
    }

    async function distributeWeekly() {
      const confirmed = await confirmDialog('Distribute Weekly',
        'Auto-distribute and optimize routes for all jobs this week. Jobs stay on their assigned days.',
        'Distribute', 'Cancel');
      if (!confirmed) return;
      
      showToast('info', 'Processing', 'Distributing for the week...');
      const startOfWeek = getStartOfWeek(currentDate);
      
      for (let i = 0; i < 7; i++) {
        const date = addDays(startOfWeek, i);
        const dateStr = formatDateStr(date);
        const daySchedules = schedules.filter(s => s.date === dateStr && s.status !== 'cancelled');
        if (daySchedules.length > 0) await distributeAndRouteDay(dateStr);
      }
      showToast('success', 'Complete', 'Weekly distribution complete');
    }

    function updateOfficeDisplay() {
      const startDisplay = document.getElementById('startAddressDisplay');
      const endDisplay = document.getElementById('endAddressDisplay');
      if (startDisplay) {
        startDisplay.textContent = officeSettings.start?.street 
          ? `${officeSettings.start.street}, ${officeSettings.start.city || ''}` : 'Not set';
      }
      if (endDisplay) {
        endDisplay.textContent = officeSettings.end?.street 
          ? `${officeSettings.end.street}, ${officeSettings.end.city || ''}` : 'Same as start';
      }
    }

    function openOfficeModal() {
      if (officeSettings.start) {
        document.getElementById('officeStreet').value = officeSettings.start.street || '';
        document.getElementById('officeCity').value = officeSettings.start.city || '';
        document.getElementById('officeState').value = officeSettings.start.state || '';
        document.getElementById('officeZip').value = officeSettings.start.zip || '';
      }
      if (officeSettings.end?.street) {
        document.getElementById('differentEndLocation').checked = true;
        document.getElementById('endLocationFields').classList.remove('hidden');
        document.getElementById('endStreet').value = officeSettings.end.street || '';
        document.getElementById('endCity').value = officeSettings.end.city || '';
        document.getElementById('endState').value = officeSettings.end.state || '';
        document.getElementById('endZip').value = officeSettings.end.zip || '';
      } else {
        document.getElementById('differentEndLocation').checked = false;
        document.getElementById('endLocationFields').classList.add('hidden');
      }
      openModal('officeModal');
    }

    async function saveOfficeSettings() {
      const startStreet = document.getElementById('officeStreet').value.trim();
      if (!startStreet) { showToast('error', 'Error', 'Please enter office address'); return; }
      // Validate ZIPs to reduce geocoding failures
      const startZip = document.getElementById('officeZip').value.trim();
      const endZip = document.getElementById('endZip').value.trim();
      const zipRegex = /^\d{5}$/;
      if (startZip && !zipRegex.test(startZip)) { showToast('error', 'Invalid ZIP', 'Start ZIP must be a 5-digit number'); return; }
      if (document.getElementById('differentEndLocation').checked && endZip && !zipRegex.test(endZip)) { showToast('error', 'Invalid ZIP', 'End ZIP must be a 5-digit number'); return; }

      // Preserve previous settings for audit tracking
      const prevOfficeSettings = JSON.parse(JSON.stringify(officeSettings || {}));

      let startCoords = null;
      if (googleMapsApiKey && startStreet) {
        startCoords = await geocodeAddress(startStreet, 
          document.getElementById('officeCity').value.trim(),
          document.getElementById('officeState').value.trim(),
          document.getElementById('officeZip').value.trim());
        if (!startCoords) {
          showToast('warning', 'Geocode failed', 'Start address could not be geocoded. Verify address and ZIP to improve map accuracy.');
        }
      }
      
      officeSettings.start = {
        street: startStreet,
        city: document.getElementById('officeCity').value.trim(),
        state: document.getElementById('officeState').value.trim(),
        zip: document.getElementById('officeZip').value.trim(),
        coordinates: startCoords
      };
      
      if (document.getElementById('differentEndLocation').checked) {
        let endCoords = null;
        const endStreet = document.getElementById('endStreet').value.trim();
        if (googleMapsApiKey && endStreet) {
          endCoords = await geocodeAddress(endStreet,
            document.getElementById('endCity').value.trim(),
            document.getElementById('endState').value.trim(),
            document.getElementById('endZip').value.trim());
          if (!endCoords) {
            showToast('warning', 'Geocode failed', 'End address could not be geocoded. Verify address and ZIP to improve map accuracy.');
          }
        }
        officeSettings.end = {
          street: endStreet,
          city: document.getElementById('endCity').value.trim(),
          state: document.getElementById('endState').value.trim(),
          zip: document.getElementById('endZip').value.trim(),
          coordinates: endCoords
        };
      } else {
        officeSettings.end = null;
      }
      
      try {
        const configRef = doc(db, 'config', 'officeSettings');
        // Use setDoc with merge to always write to the named document and create it if it doesn't exist
        await setDoc(configRef, officeSettings, { merge: true });
        showToast('success', 'Saved', 'Office settings updated');
        closeModal('officeModal');
        updateOfficeDisplay();
        // Audit: log settings change with details
        try {
          const changes = trackChanges(prevOfficeSettings, officeSettings);
          const isNew = !prevOfficeSettings || Object.keys(prevOfficeSettings).length === 0;
          const auditAction = isNew ? AuditActions.CREATE : AuditActions.UPDATE;
          if (changes) {
            await logAudit(auditAction, AuditModules.SETTINGS, 'officeSettings', 'Office Settings', changes);
          }
        } catch (auditErr) {
          
        }
      } catch (e) {  showToast('error', 'Error', 'Save failed'); }
    }

    async function geocodeAddress(street, city, state, zip) {
      if (!googleMapsApiKey) return null;
      const fullAddress = `${street}, ${city}, ${state} ${zip}`;
      try {
        const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(fullAddress)}&key=${googleMapsApiKey}`);
        const data = await response.json();
        if (data.status === 'OK' && data.results.length > 0) {
          return { lat: data.results[0].geometry.location.lat, lng: data.results[0].geometry.location.lng };
        }
        return null;
      } catch (e) {  return null; }
    }

    // ============================================
    // HELPER FUNCTIONS
    // ============================================
function formatDateStr(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function getStartOfWeek(date) {
      const d = new Date(date);
      const day = d.getDay();
      return addDays(d, -day);
    }

    function getServiceSummary(client) {
      if (!client?.areas) return 'Standard';
      
      const floors = [];
      if (client.areas.basement?.includedInBase) floors.push('Basement');
      if (client.areas.mainLevel?.includedInBase) floors.push('Main');
      if (client.areas.upstairs?.includedInBase) floors.push('Upstairs');
      
      return floors.length > 0 ? floors.join('+') : 'Standard';
    }
    // Add after DOMContentLoaded or in init
    function initStickyActions() {
      const actions = document.getElementById('calendarActions');
      if (!actions) return;
      
      const observer = new IntersectionObserver(
        ([entry]) => {
          actions.classList.toggle('stuck', entry.intersectionRatio < 1);
        },
        { threshold: [1], rootMargin: '-1px 0px 0px 0px' }
      );
      
      observer.observe(actions);
    }

    function populateClientSelect(filter = '') {
      const select = document.getElementById('scheduleClient');
      const currentVal = select.value;
      const inputEl = document.getElementById('scheduleClientSearch');
      if (currentVal && inputEl) {
        const selectedClient = clients.find(c => c.id === currentVal);
        if (selectedClient) inputEl.value = `${selectedClient.lastName}, ${selectedClient.firstName} - ${selectedClient.address?.street || ''}`;
      }
      const q = (filter || '').trim().toLowerCase();
      const filtered = q ? clients.filter(c => {
        const full = `${c.firstName} ${c.lastName} ${c.address?.street || ''} ${c.houseCode || ''}`.toLowerCase();
        return full.indexOf(q) !== -1;
      }) : clients;
      select.innerHTML = '<option value="">-- Select Client --</option>' +
        filtered.map(c => `<option value="${c.id}">${c.lastName}, ${c.firstName} - ${c.address?.street || ''}</option>`).join('');
      // Also render the dropdown list for the combobox so users can search and scroll
      const list = document.getElementById('scheduleClientList');
      if (list) {
        list.innerHTML = filtered.map(c => `<div class="search-option" role="option" data-id="${c.id}" style="padding:8px 10px; cursor:pointer;">${c.lastName}, ${c.firstName} - ${c.address?.street || ''}</div>`).join('');
        // If there are options and the combobox is focused, show the list
        if (currentVal) {
          const item = list.querySelector(`.search-option[data-id="${currentVal}"]`);
          if (item) item.classList.add('focused');
        }
      }
      // Preserve selection if it still exists in the filtered list
      if (currentVal && filtered.some(c => c.id === currentVal)) select.value = currentVal;
    }

    function populateTeamSelect() {
      const select = document.getElementById('scheduleTeam');
      select.innerHTML = '<option value="">-- Select Team --</option>' +
        teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
      
      const filterSelect = document.getElementById('teamFilter');
      filterSelect.innerHTML = '<option value="">All Teams</option>' +
        teams.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
      // Default the schedule team to the first team if available
      if (teams && teams.length > 0 && select.value === '') select.value = teams[0].id;
    }

    function onClientChange() {
      const clientId = document.getElementById('scheduleClient').value;
      selectedClient = clients.find(c => c.id === clientId);
      
      const preview = document.getElementById('clientPreview');
      const addonsSection = document.getElementById('addonsSection');
      const addonsContainer = document.getElementById('addonsContainer');
      
      if (selectedClient) {
        preview.classList.remove('hidden');
        document.getElementById('previewClientName').textContent = 
          `${selectedClient.firstName} ${selectedClient.lastName}`;
        document.getElementById('previewClientAddress').textContent = 
          selectedClient.address?.street || '';
        document.getElementById('previewClientPrice').textContent = 
          formatCurrency(selectedClient.basePrice || 0);
        document.getElementById('previewClientSchedule').textContent = 
          i18n.t(`scheduleTypes.${selectedClient.scheduleType}`) || selectedClient.scheduleType;
        
        // Show house code if available
        const houseCodeEl = document.getElementById('previewClientHouseCode');
        if (selectedClient.houseCode) {
          houseCodeEl.style.display = 'block';
          houseCodeEl.querySelector('span').textContent = selectedClient.houseCode;
        } else {
          houseCodeEl.style.display = 'none';
        }
        
        // Build add-ons from client's areas that are NOT included in base
        const areas = selectedClient.areas || {};
        const extraAreas = [];

        const floorLabels = {
          basement: 'üèöÔ∏è Basement',
          mainLevel: 'üè† Main Level',
          upstairs: '‚¨ÜÔ∏è Upstairs'
        };

        const areaLabels = {
          bathrooms: 'Bathrooms',
          bedrooms: 'Bedrooms',
          kitchen: 'Kitchen',
          livingRoom: 'Living Room',
          diningRoom: 'Dining Room',
          laundryRoom: 'Laundry Room',
          office: 'Office',
          fridge: 'Fridge',
          masterBath: 'Master Bath',
          masterRoom: 'Master Room'
        };

        // Iterate through each floor and its areas
        for (const [floorKey, floorData] of Object.entries(areas)) {
          if (!floorData || typeof floorData !== 'object') continue;

          // Iterate through each area within the floor
          for (const [areaId, areaConfig] of Object.entries(floorData)) {
            if (areaConfig && areaConfig.selected && !areaConfig.includedInBase && areaConfig.extraPrice > 0) {
              const areaKey = `${floorKey}-${areaId}`;
              const floorLabel = floorLabels[floorKey] || floorKey;
              const areaLabel = areaLabels[areaId] || areaId;

              extraAreas.push({
                key: areaKey,
                label: `${floorLabel} - ${areaLabel}`,
                price: areaConfig.extraPrice || 0,
                frequency: areaConfig.extraFrequency || 'monthly'
              });
            }
          }
        }

        if (extraAreas.length > 0) {
          addonsSection.style.display = 'block';
          addonsContainer.innerHTML = extraAreas.map(area => `
            <label class="form-check">
              <input type="checkbox" class="form-check-input addon-checkbox" data-area="${area.key}" data-price="${area.price}" data-frequency="${area.frequency}" onchange="updateTotalPrice()">
              <span class="form-check-label">${area.label} <span class="text-gray-500">(${area.frequency}, +${formatCurrency(area.price)})</span></span>
            </label>
          `).join('');

          // Auto-select extras that should appear on the schedule date
          const scheduleDate = document.getElementById('scheduleDate').value;
          if (scheduleDate && selectedClient) {
            const calculatedAddOns = calculateExtrasForDate(selectedClient, scheduleDate);
            calculatedAddOns.forEach(addon => {
              const checkbox = addonsContainer.querySelector(`[data-area="${addon.area}"]`);
              if (checkbox) {
                checkbox.checked = true;
              }
            });
          }
        } else {
          addonsSection.style.display = 'none';
          addonsContainer.innerHTML = '';
        }
        
        // Time slot no longer used. Keep hidden input empty.
        document.getElementById('scheduleTimeSlot').value = '';
      } else {
        preview.classList.add('hidden');
        addonsSection.style.display = 'none';
        addonsContainer.innerHTML = '';
      }
      
      updateTotalPrice();
    }

    window.updateTotalPrice = function() {
      if (!selectedClient) {
        document.getElementById('scheduleTotalPrice').textContent = formatCurrency(0);
        return;
      }
      
      let total = selectedClient.basePrice || 0;
      
      // Add extra area charges from checked add-ons
      document.querySelectorAll('.addon-checkbox:checked').forEach(checkbox => {
        total += parseFloat(checkbox.dataset.price) || 0;
      });
      
      document.getElementById('scheduleTotalPrice').textContent = formatCurrency(total);
    }

    function updateLanguage() {
      const lang = i18n.getLanguage();
      document.getElementById('langLabel').textContent = lang === 'en' ? 'ES' : 'EN';
      i18n.updatePageTranslations();
    }

    // ============================================
    // BULK ADD CLIENTS
    // ============================================
    async function openBulkAddModal() {
      const dateStr = selectedDate;

      // Get already scheduled clients for this day
      const daySchedules = schedules.filter(s => s.date === dateStr);
      const scheduledClientIds = new Set(daySchedules.map(s => s.clientId));

      // Get available clients (not scheduled for this day)
      const availableClients = clients
        .filter(c => !scheduledClientIds.has(c.id))
        .sort((a, b) => `${a.lastName} ${a.firstName}`.localeCompare(`${b.lastName} ${b.firstName}`));

      // Store available clients for filtering
      window.bulkAvailableClients = availableClients;

      // Populate checkboxes
      const checkboxesContainer = document.getElementById('bulkClientCheckboxes');
      checkboxesContainer.innerHTML = availableClients
        .map(c => `
          <label class="form-check" style="display: flex; align-items: center; margin-bottom: var(--space-2); cursor: pointer;">
            <input type="checkbox" class="form-check-input bulk-client-checkbox" value="${c.id}" style="cursor: pointer;">
            <span class="form-check-label" style="cursor: pointer;">${c.lastName}, ${c.firstName}</span>
            <span class="text-gray-500" style="font-size: 0.85rem; margin-left: auto;">${c.address?.street || ''}</span>
          </label>
        `)
        .join('');

      // Populate team select with first team as default
      const teamSelect = document.getElementById('bulkTeamSelect');
      teamSelect.innerHTML = teams
        .map((t, idx) => `<option value="${t.id}" ${idx === 0 ? 'selected' : ''}>${t.name}</option>`)
        .join('');

      // If no teams, add unassigned option
      if (teams.length === 0) {
        teamSelect.innerHTML = '<option value="">-- Unassigned --</option>';
      }

      // Setup search functionality
      const searchInput = document.getElementById('bulkClientSearch');
      searchInput.value = '';
      searchInput.addEventListener('input', filterBulkClients);

      openModal('bulkAddModal');
    }

    function filterBulkClients() {
      const searchTerm = document.getElementById('bulkClientSearch').value.toLowerCase();
      const checkboxes = document.querySelectorAll('.bulk-client-checkbox');

      checkboxes.forEach(checkbox => {
        const label = checkbox.closest('label');
        const clientText = label.textContent.toLowerCase();
        const isMatch = searchTerm === '' || clientText.includes(searchTerm);
        label.style.display = isMatch ? 'flex' : 'none';
      });
    }

    async function confirmBulkAdd() {
      // Get selected checkboxes
      const selectedCheckboxes = document.querySelectorAll('.bulk-client-checkbox:checked');
      const selectedClients = Array.from(selectedCheckboxes).map(cb => cb.value);
      const teamId = document.getElementById('bulkTeamSelect').value;
      const duration = parseFloat(document.getElementById('bulkDuration').value) || 2;
      const dateStr = selectedDate;

      if (selectedClients.length === 0) {
        showToast('warning', 'No Clients', 'Please select at least one client');
        return;
      }

      // Show loading state
      const confirmBtn = document.getElementById('confirmBulkAddBtn');
      const originalText = confirmBtn.textContent;
      confirmBtn.disabled = true;
      confirmBtn.innerHTML = '<span class="spinner"></span> Adding...';

      try {
        let added = 0;

        for (const clientId of selectedClients) {
          const client = clients.find(c => c.id === clientId);
          if (!client) continue;

          // Check for duplicate
          const existing = schedules.find(s => s.clientId === clientId && s.date === dateStr);
          if (existing) continue;

          const scheduleData = {
            clientId,
            teamId,
            date: dateStr,
            serviceDetails: {
              addOns: [],
              totalPrice: client.basePrice || 0
            },
            estimatedDuration: duration,
            status: 'scheduled',
            notes: '',
            routeOrder: 0,
            createdAt: Timestamp.now(),
            updatedAt: Timestamp.now()
          };

          try {
            await addDoc(collection(db, 'schedules'), scheduleData);
            added++;
          } catch (error) {
            console.error('Error adding schedule:', error);
          }
        }

        showToast('success', 'Success', `${added} clients added to ${dateStr}`);
        closeModal('bulkAddModal');
        await loadSchedules();
        renderCalendar();
        if (selectedDate === dateStr) showDayJobs(dateStr);

      } catch (error) {
        console.error('Error:', error);
        showToast('error', 'Error', 'Failed to add clients');
      } finally {
        confirmBtn.disabled = false;
        confirmBtn.textContent = originalText;
      }
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================
    function setupEventListeners() {
      // Mobile menu
      document.getElementById('menuToggle').addEventListener('click', () => {
        document.getElementById('sidebar').classList.toggle('open');
        document.getElementById('sidebarOverlay').classList.toggle('active');
      });

      document.getElementById('sidebarOverlay').addEventListener('click', () => {
        document.getElementById('sidebar').classList.remove('open');
        document.getElementById('sidebarOverlay').classList.remove('active');
      });

      // Language
      document.getElementById('langToggle').addEventListener('click', () => {
        i18n.toggleLanguage();
        updateLanguage();
        renderCalendar();
      });

      // Logout
      document.getElementById('logoutBtn').addEventListener('click', async () => {
        await signOut(auth);
        window.location.href = 'index.html';
      });

      // Calendar navigation
      document.getElementById('prevBtn').addEventListener('click', () => {
        if (currentView === 'month') {
          currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
        } else if (currentView === 'week') {
          currentDate = addDays(currentDate, -7);
        } else {
          currentDate = addDays(currentDate, -1);
        }
        loadSchedules().then(() => renderCalendar());
      });

      // Week selector navigation
      document.getElementById('prevWeekBtn')?.addEventListener('click', () => navigateWeek(-1));
      document.getElementById('nextWeekBtn')?.addEventListener('click', () => navigateWeek(1));

      document.getElementById('nextBtn').addEventListener('click', () => {
        if (currentView === 'month') {
          currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
        } else if (currentView === 'week') {
          currentDate = addDays(currentDate, 7);
        } else {
          currentDate = addDays(currentDate, 1);
        }
        loadSchedules().then(() => renderCalendar());
      });

      document.getElementById('todayBtn').addEventListener('click', () => {
        currentDate = new Date();
        loadSchedules().then(() => renderCalendar());
      });

      // View buttons
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          currentView = btn.dataset.view;
          
          document.getElementById('monthView').classList.remove('active');
          document.getElementById('weekView').classList.remove('active');
          document.getElementById('dayView').classList.remove('active');
          document.getElementById(currentView + 'View').classList.add('active');
          
          renderCalendar();
        });
      });

      // Delete all day schedules
      document.getElementById('deleteAllDayJobsBtn')?.addEventListener('click', () => {
        if (selectedDate) deleteAllDaySchedules(selectedDate);
      });

      // Team filter
      document.getElementById('teamFilter').addEventListener('change', (e) => {
        teamFilter = e.target.value;
        renderCalendar();
      });

      // Add schedule
      document.getElementById('addScheduleBtn').addEventListener('click', () => openAddScheduleModal());

      // Auto schedule
      document.getElementById('autoScheduleBtn').addEventListener('click', openAutoScheduleModal);

      // Distribute weekly
      document.getElementById('distributeWeeklyBtn')?.addEventListener('click', distributeWeekly);

      // Schedule Modal
      document.getElementById('closeScheduleModal').addEventListener('click', () => closeModal('scheduleModal'));
      document.getElementById('cancelScheduleBtn').addEventListener('click', () => closeModal('scheduleModal'));
      document.getElementById('saveScheduleBtn').addEventListener('click', saveSchedule);
      
      document.getElementById('scheduleClient').addEventListener('change', onClientChange);

      // When schedule date changes, recalculate which extras should appear
      document.getElementById('scheduleDate').addEventListener('change', () => {
        if (selectedClient) {
          const scheduleDate = document.getElementById('scheduleDate').value;
          const addonsContainer = document.getElementById('addonsContainer');

          // Clear all checkboxes first
          addonsContainer.querySelectorAll('.addon-checkbox').forEach(checkbox => {
            checkbox.checked = false;
          });

          // Auto-select extras that should appear on the new schedule date
          const calculatedAddOns = calculateExtrasForDate(selectedClient, scheduleDate);
          calculatedAddOns.forEach(addon => {
            const checkbox = addonsContainer.querySelector(`[data-area="${addon.area}"]`);
            if (checkbox) {
              checkbox.checked = true;
            }
          });

          updateTotalPrice();
        }
      });

      // Client combobox: filters the schedule client select dropdown and shows a list for selection
      (function() {
        const clientSearchEl = document.getElementById('scheduleClientSearch');
        const clientListEl = document.getElementById('scheduleClientList');
        const clientCombobox = document.getElementById('scheduleClientCombobox');
        const clientCaret = document.getElementById('scheduleClientCaret');
        let listOpen = false;
        let activeIdx = -1;
        function focusListItem(items, idx) {
          items.forEach((it, i) => it.classList.toggle('focused', i === idx));
          if (items[idx]) items[idx].scrollIntoView({ block: 'nearest' });
        }
        function showClientList(show) {
          listOpen = !!show;
          if (!clientListEl) return;
          clientListEl.classList.toggle('hidden', !listOpen);
          if (clientSearchEl) clientSearchEl.setAttribute('aria-expanded', listOpen ? 'true' : 'false');
          if (!listOpen) activeIdx = -1;
        }
        clientSearchEl?.addEventListener('input', (e) => {
          const q = e.target.value;
          populateClientSelect(q);
          showClientList(true);
        });
        // Click caret/toggle
        clientCaret?.addEventListener('click', (e) => {
          e.stopPropagation();
          if (listOpen) showClientList(false);
          else {
            populateClientSelect('');
            clientSearchEl.focus();
            showClientList(true);
          }
        });
        // Click to open list
        clientCombobox?.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!listOpen) {
            populateClientSelect('');
            clientSearchEl.focus();
            showClientList(true);
          }
        });
        // Click outside closes the list
        document.addEventListener('click', (e) => {
          const target = e.target;
          const combo = document.getElementById('scheduleClientCombo');
          if (!combo) return;
          if (!combo.contains(target)) showClientList(false);
        });
        // Keyboard navigation
        clientSearchEl?.addEventListener('keydown', (e) => {
          const items = clientListEl ? clientListEl.querySelectorAll('.search-option') : [];
          if (!items || items.length === 0) return;
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIdx = Math.min(activeIdx + 1, items.length - 1);
            focusListItem(items, activeIdx);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIdx = Math.max(activeIdx - 1, 0);
            focusListItem(items, activeIdx);
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (activeIdx >= 0 && items[activeIdx]) items[activeIdx].click();
          } else if (e.key === 'Escape') {
            showClientList(false);
            clientSearchEl.blur();
          }
        });
        // Delegate click on list
        clientListEl?.addEventListener('click', (e) => {
          const li = e.target.closest('.search-option');
          if (!li) return;
          const id = li.dataset.id;
          const hidden = document.getElementById('scheduleClient');
          if (hidden) hidden.value = id;
          clientSearchEl.value = li.textContent;
          // Trigger change for rest of UI
          if (typeof onClientChange === 'function') onClientChange();
          showClientList(false);
        });
      })();

      // View Schedule Modal
      document.getElementById('closeViewScheduleModal').addEventListener('click', () => closeModal('viewScheduleModal'));
      document.getElementById('closeViewScheduleBtn').addEventListener('click', () => closeModal('viewScheduleModal'));

      // Auto Schedule Modal
      document.getElementById('closeAutoScheduleModal').addEventListener('click', () => closeModal('autoScheduleModal'));
      document.getElementById('cancelAutoScheduleBtn').addEventListener('click', () => closeModal('autoScheduleModal'));
      document.getElementById('generateSchedulesBtn').addEventListener('click', generateSchedules);
      document.getElementById('autoClientFilter').addEventListener('change', estimateJobs);

      // Day Jobs Modal
      document.getElementById('closeDayJobsModal').addEventListener('click', () => closeModal('dayJobsModal'));
      document.getElementById('closeDayJobsBtn').addEventListener('click', () => closeModal('dayJobsModal'));
      document.getElementById('addJobForDayBtn').addEventListener('click', () => {
        closeModal('dayJobsModal');
        openAddScheduleModal(selectedDate);
      });
      document.getElementById('bulkAddJobsBtn')?.addEventListener('click', () => {
        closeModal('dayJobsModal');
        openBulkAddModal();
      });
      document.getElementById('distributeAndRouteBtn')?.addEventListener('click', () => {
        if (selectedDate) distributeAndRouteDay(selectedDate);
      });
      // Preview all team routes
      document.getElementById('previewAllRoutesBtn')?.addEventListener('click', () => {
        if (selectedDate) previewAllTeamRoutes(selectedDate);
      });

      // Bulk Add Modal
      document.getElementById('closeBulkAddModal').addEventListener('click', () => closeModal('bulkAddModal'));
      document.getElementById('cancelBulkAddBtn').addEventListener('click', () => closeModal('bulkAddModal'));
      document.getElementById('confirmBulkAddBtn').addEventListener('click', confirmBulkAdd);

      // Office Modal
      document.getElementById('editOfficeBtn')?.addEventListener('click', openOfficeModal);
      document.getElementById('closeOfficeModal')?.addEventListener('click', () => closeModal('officeModal'));
      document.getElementById('cancelOfficeBtn')?.addEventListener('click', () => closeModal('officeModal'));
      document.getElementById('saveOfficeBtn')?.addEventListener('click', saveOfficeSettings);
      document.getElementById('differentEndLocation')?.addEventListener('change', (e) => {
        document.getElementById('endLocationFields')?.classList.toggle('hidden', !e.target.checked);
      });

      // Modal backdrop
      document.getElementById('modalBackdrop').addEventListener('click', closeAllModals);
    }
  </script>
</body>
</html>